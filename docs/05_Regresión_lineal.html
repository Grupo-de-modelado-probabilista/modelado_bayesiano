<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.335">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Estadística: inferencia y modelado - 6&nbsp; Regresión Lineal</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./06_Generalizando_modelos_lineales.html" rel="next">
<link href="./04_Diagnóstico_MCMC.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Regresión Lineal</span></h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Estadística: inferencia y modelado</a> 
        <div class="sidebar-tools-main tools-wide">
    <a href="" title="" id="sidebar-tool-dropdown-0" class="sidebar-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi bi-github"></i></a>
    <ul class="dropdown-menu" aria-labelledby="sidebar-tool-dropdown-0">
        <li>
          <a class="dropdown-item sidebar-tools-main-item" href="https://github.com/Grupo-de-modelado-probabilista/Modelado_Bayesiano">
          Fuente
          </a>
        </li>
        <li>
          <a class="dropdown-item sidebar-tools-main-item" href="https://github.com/Grupo-de-modelado-probabilista/Modelado_Bayesiano/issues/new">
          Reportar errores
          </a>
        </li>
    </ul>
  <a href="" class="quarto-color-scheme-toggle sidebar-tool" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
  <a href="" class="quarto-reader-toggle sidebar-tool" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
    </div>
      </div>
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">‎</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./00_Probabilidad.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Probabilidad</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01_Inferencia_Bayesiana.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Inferencia Bayesiana</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02_Programación_probabilística.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Programación probabilista</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03_Modelos_jerárquicos.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Modelado Jerárquico</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04_Diagnóstico_MCMC.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Diagnóstico del muestreo</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05_Regresión_lineal.html" class="sidebar-item-text sidebar-link active"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Regresión Lineal</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06_Generalizando_modelos_lineales.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Generalizando modelos lineales</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07_Comparación_de_modelos.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Comparación de modelos</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#regresión-lineal" id="toc-regresión-lineal" class="nav-link active" data-scroll-target="#regresión-lineal"><span class="toc-section-number">7</span>  Regresión lineal</a>
  <ul class="collapse">
  <li><a href="#modelos-lineales-y-autocorrelación" id="toc-modelos-lineales-y-autocorrelación" class="nav-link" data-scroll-target="#modelos-lineales-y-autocorrelación"><span class="toc-section-number">7.1</span>  Modelos lineales y autocorrelación</a></li>
  <li><a href="#interpretando-y-visualizando-el-posterior" id="toc-interpretando-y-visualizando-el-posterior" class="nav-link" data-scroll-target="#interpretando-y-visualizando-el-posterior"><span class="toc-section-number">7.2</span>  Interpretando y visualizando el posterior</a></li>
  <li><a href="#regresión-lineal-robusta" id="toc-regresión-lineal-robusta" class="nav-link" data-scroll-target="#regresión-lineal-robusta"><span class="toc-section-number">7.3</span>  Regresión lineal robusta</a></li>
  <li><a href="#regresión-lineal-jerárquica" id="toc-regresión-lineal-jerárquica" class="nav-link" data-scroll-target="#regresión-lineal-jerárquica"><span class="toc-section-number">7.4</span>  Regresión lineal jerárquica</a></li>
  <li><a href="#regresión-lineal-multiple" id="toc-regresión-lineal-multiple" class="nav-link" data-scroll-target="#regresión-lineal-multiple"><span class="toc-section-number">7.5</span>  Regresión lineal Multiple</a></li>
  <li><a href="#variables-de-confusión-y-variables-redundantes" id="toc-variables-de-confusión-y-variables-redundantes" class="nav-link" data-scroll-target="#variables-de-confusión-y-variables-redundantes"><span class="toc-section-number">7.6</span>  Variables de confusión y variables redundantes</a></li>
  <li><a href="#multicolinearidad-o-cuando-la-correlación-es-demasiado-alta" id="toc-multicolinearidad-o-cuando-la-correlación-es-demasiado-alta" class="nav-link" data-scroll-target="#multicolinearidad-o-cuando-la-correlación-es-demasiado-alta"><span class="toc-section-number">7.7</span>  Multicolinearidad o cuando la correlación es demasiado alta</a></li>
  <li><a href="#variables-de-efecto-de-enmascaramiento" id="toc-variables-de-efecto-de-enmascaramiento" class="nav-link" data-scroll-target="#variables-de-efecto-de-enmascaramiento"><span class="toc-section-number">7.8</span>  Variables de efecto de enmascaramiento</a></li>
  <li><a href="#resumen" id="toc-resumen" class="nav-link" data-scroll-target="#resumen"><span class="toc-section-number">7.9</span>  Resumen</a></li>
  </ul></li>
  <li><a href="#ejercicios" id="toc-ejercicios" class="nav-link" data-scroll-target="#ejercicios"><span class="toc-section-number">8</span>  Ejercicios</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Regresión Lineal</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">import</span> arviz <span class="im">as</span> az</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="im">import</span> pymc <span class="im">as</span> pm</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="im">from</span> aesara <span class="im">import</span> shared</span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="im">import</span> scipy.stats <span class="im">as</span> stats</span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="im">import</span> xarray <span class="im">as</span> xr</span>
<span id="cb1-9"><a href="#cb1-9"></a></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="im">import</span> warnings</span>
<span id="cb1-11"><a href="#cb1-11"></a>warnings.simplefilter(action<span class="op">=</span><span class="st">'ignore'</span>, category<span class="op">=</span><span class="pp">FutureWarning</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a>plt.style.use(<span class="st">'arviz-doc'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La música, ya sea la Suite para violonchelo N° 1 de Bach, <em>el pibe cantina</em> de damas gratis o Libertango de Piazzolla, se construye con patrones recurrentes. Las mismas escalas, progressiones de acordes, riffs, etc. aparecen una y otra vez dando lugar a un maravilloso paisaje sonoro capaz de provocar y modular toda la gama de emociones humanas. De manera similar, el universo estadístico está compuesto de patrones recurrentes, pequeños motivos que aparecen una y otra vez. En este capítulo, vamos a ver uno de los más populares y útiles de ellos, el modelo lineal. Este es un modelo muy útil en sí mismo y también el componente básico de muchos otros modelos. Es probable que algunos de los siguientes términos te resulten familiares: regresión lineal simple, regresión múltiple, regresión logística, ANOVA, ANCOVA. Todos estos métodos son variaciones del mismo motivo subyacente, el modelo de regresión lineal. En este capítulo, cubriremos los siguientes temas:</p>
<ul>
<li>Regresión lineal simple</li>
<li>Regresión lineal robusta</li>
<li>Regresión jerárquica</li>
<li>Regresión polinomial</li>
<li>Regresión múltiple</li>
<li>Interacciones</li>
<li>Varianza variable</li>
</ul>
<section id="regresión-lineal" class="level1" data-number="7">
<h1 data-number="7"><span class="header-section-number">7</span> Regresión lineal</h1>
<p>Supongamos que tenemos una variable <span class="math inline">\(X\)</span>, y a partir de esta queremos predecir o modelar una variable <span class="math inline">\(Y\)</span>. Además, estás variables se encuentran apareadas ${(x_1,y_1), (x_2,y_2),(x_n,y_n)} $. En el caso más simple <span class="math inline">\(X\)</span> e <span class="math inline">\(Y\)</span> son variables aleatorias continuas y unidimensionales, usando Python las representaríamos usando <em>arrays</em> de dimensión 1 de tipo flotante.</p>
<p>Las variable <span class="math inline">\(Y\)</span> suele recibir distintos nombres como variable dependiente, predicha o respuesta, mientras que <span class="math inline">\(X\)</span> recibe nombres como variable independiente, predictora o <em>de entrada</em>. En <em>Machine learning</em> es común hablar de <em>features</em> en vez de variables y es común pensar que una regresión lineal es un ejemplo de <a href="https://es.wikipedia.org/wiki/Aprendizaje_supervisado">aprendizaje supervisado</a>.</p>
<p>Cuando tenemos más de una variable independiente es común representarla como una matriz <span class="math inline">\(\boldsymbol{X}\)</span> (usualmente llamada <a href="https://en.wikipedia.org/wiki/Design_matrix">matriz de diseño</a>), donde por lo general las columnas representan distintos tipos de variables (o <em>features</em>) y las filas distintas observaciones, instancias , sujetos, etc. Este tipo de modelo se llama regresión lineal múltiple o regresión lineal multivariable y es quizá el caso más común de regresión lineal. El nombre regresión lineal multivariada debería reservarse a casos en que tenemos más de una variable respuesta, aunque es muy común en literatura que estos términos se usen de forma intercambiable.</p>
<p>Algunos ejemplos donde se pueden usar modelos de regresión lineal:</p>
<ul>
<li>Modelar la relación entre factores como la lluvia, la salinidad del suelo y la presencia de fertilizante en la productividad de los cultivos. Podríamos tener interés en preguntas como: ¿Es lineal la relación? ¿Qué tan fuerte es esta relación? ¿Cuál variable explica la mayor parte del efecto?</li>
<li>Encontrar una relación lineal entre el consumo promedio de chocolate por país y la cantidad de premios Nobel en cada país. Y luego entender por qué esta relación podría ser espuria.</li>
<li>Predecir el monto de la factura de gas de tu casa a partir de la variable radiación solar ¿Cuán precisa es esta predicción?</li>
</ul>
<p>Habiendo ya discutido algunas ideas generales sobre regresión lineal veamos cómo es que este modelo se construye. Podemos describir una relación lineal usando la siguiente expresión:</p>
<p><span class="math display">\[y_i = \alpha + x_i \beta  \tag{3.1}\]</span></p>
<p>Según esta expresión cada observación <span class="math inline">\(y_i\)</span> se obtiene a partir de multiplicar <span class="math inline">\(x_i\)</span> por un coeficiente <span class="math inline">\(\beta\)</span> y luego se le suma el coeficiente <span class="math inline">\(\alpha\)</span>.</p>
<p>El parámetro <span class="math inline">\(\beta\)</span> controla la <em>pendiente</em> en la relación lineal, podemos interpretarlo como el cambio en la variable <span class="math inline">\(Y\)</span> por cambio de unidad en la variable <span class="math inline">\(X\)</span>. El parámetro <span class="math inline">\(\alpha\)</span> se conoce como intercepto u ordenada al origen, y podemos interpretarlo como el valor de <span class="math inline">\(y_i\)</span> cuando <span class="math inline">\(x_i = 0\)</span>. Gráficamente, <span class="math inline">\(\alpha\)</span> indica el valor de <span class="math inline">\(y_i\)</span> donde la línea intercepta el eje y.</p>
<p>Un método muy popular para encontrar los parámetros para un modelo lineal se conoce como <em>ajuste por mínimos cuadrados</em>. Este método devuelve un valor para <span class="math inline">\(\alpha\)</span> y uno para <span class="math inline">\(\beta\)</span> de tal forma que esos valores sean los que minimizan el error cuadrático medio entre los <span class="math inline">\(y\)</span> observados y predichos. Es decir obtenemos una sola linea recta, la “mejor” según este criterio (hay otros).</p>
<p>Nosotros vamos a seguir una ruta diferente, para ello vamos a reformular la expresión 3.1 en términos probabilístas:</p>
<p><span class="math display">\[Y \sim \mathcal{N}(\mu=\alpha + X \beta, \epsilon) \tag{3.2}\]</span></p>
<p>Es decir <span class="math inline">\(Y\)</span> es una variable aleatoria distribuida según una Gaussiana con media <span class="math inline">\(\alpha + X \beta\)</span> desviación estándar <span class="math inline">\(\epsilon\)</span>. Desde esta perspectiva una regresión lineal es una extensión de un modelo Gaussiano donde en vez de estimar la media de forma directa la calculamos como una una función lineal de las variables predictoras.</p>
<p>Como desconocemos los valores de los parámetros <span class="math inline">\(\alpha\)</span>, <span class="math inline">\(\beta\)</span> y <span class="math inline">\(\epsilon\)</span> debemos asignarles distribuciones <em>a priori</em>. Si usáramos <em>a prioris</em> planos entonces el valor <em>máximo a posteriori</em> (la moda del posterior) sería el mismo que el encontrado usando mínimos cuadrados y el mismo que usando <em>maximum likelihood</em>. En general es posible hacer algo mejor que esto. Una elección razonable y genérica para los <em>a prioris</em> sería:</p>
<p><span class="math display">\[
\alpha \sim \mathcal{N}(\mu_\alpha, \sigma_\alpha) \\
\beta \sim \mathcal{N}(\mu_\beta, \sigma_\beta) \\
\epsilon \sim \mathcal{HN}(\sigma_\epsilon) \tag{3.3}
\]</span></p>
<p>Si no tenemos una idea muy clara sobre qué valores deberían tener los <em>a prioris</em> podemos fijar los valores de <span class="math inline">\(\sigma_{\alpha}\)</span>, <span class="math inline">\(\sigma_{\beta}\)</span> o <span class="math inline">\(\sigma_{\epsilon}\)</span> de forma tal que sean <em>grandes</em> dada la escala de los datos. En general es más fácil tener una idea de los valores que <span class="math inline">\(\beta\)</span> puede tomar por sobre los de <span class="math inline">\(\alpha\)</span>, por ejemplo solemos saber si la pendiente es positiva o negativa. Usar datos estandarizados suele ser útil para elegir <em>a prioris</em> ligeramente informativos que funciona para un amplio rango de problemas.</p>
<p>Para parámetros como <span class="math inline">\(\epsilon\)</span>, que están restringidos a los positivos, es común el uso de <em>a prioris</em> como la media Gaussiana (como en 3.3), algunas alternativas son la distribución uniforme y la media-Cauchy, mientras que la media-gaussiana y la media-Cauchy funcionan bien como <em>a prioris</em> generales, la distribución uniforme no suele ser buena idea, en general no es buena idea usar distribuciones restringidas a un rango salvo que sepamos que los parámetros realmente están restringidos a ese rango. La distribución gamma se puede usar para definir <em>a prioris</em> más informativos para <span class="math inline">\(\epsilon\)</span>, especialmente si la definimos usando la media y desviación estándar, PyMC permite definir una distribución Gamma usando dos <a href="https://docs.pymc.io/api/distributions/continuous.html#pymc3.distributions.continuous.Gamma">parametrizaciones alternativas</a>.</p>
<p>Usando diagramas de Krusche podemos representar una regresión lineal de la siguiente forma:</p>
<p><img src="img/regresión_lineal.png" width="500"></p>
<p><span class="math inline">\(\mu\)</span> está definida usando el símbolo <span class="math inline">\(=\)</span>, en vez de <span class="math inline">\(\sim\)</span>, esto se debe a que una vez conocidos <span class="math inline">\(\alpha\)</span> y <span class="math inline">\(\beta\)</span> el valor de <span class="math inline">\(\mu\)</span> queda completamente determinado. Llamamos a este tipo de variables deterministas.</p>
<p>Ahora necesitamos los datos para alimentar el modelo. Una vez más, vamos a confiar en un conjunto de datos sintéticos. Una ventaja de un conjunto de datos sintético es que conocemos los valores correctos de los parámetros y, por lo tanto, podemos verificar si podemos recuperarlos con nuestros modelos.</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a>np.random.seed(<span class="dv">1</span>)</span>
<span id="cb3-2"><a href="#cb3-2"></a>N <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>alfa_real <span class="op">=</span> <span class="fl">2.5</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>beta_real <span class="op">=</span> <span class="fl">0.9</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>eps_real <span class="op">=</span> np.random.normal(<span class="dv">0</span>, <span class="fl">0.5</span>, size<span class="op">=</span>N)</span>
<span id="cb3-6"><a href="#cb3-6"></a></span>
<span id="cb3-7"><a href="#cb3-7"></a>x <span class="op">=</span> np.random.normal(<span class="dv">10</span>, <span class="dv">1</span>, N)</span>
<span id="cb3-8"><a href="#cb3-8"></a>y_real <span class="op">=</span> alfa_real <span class="op">+</span> beta_real <span class="op">*</span> x </span>
<span id="cb3-9"><a href="#cb3-9"></a>y <span class="op">=</span> y_real <span class="op">+</span> eps_real</span>
<span id="cb3-10"><a href="#cb3-10"></a></span>
<span id="cb3-11"><a href="#cb3-11"></a><span class="co"># we can center the data</span></span>
<span id="cb3-12"><a href="#cb3-12"></a><span class="co">#x = x - x.mean()</span></span>
<span id="cb3-13"><a href="#cb3-13"></a><span class="co"># or standardize the data</span></span>
<span id="cb3-14"><a href="#cb3-14"></a><span class="co">#x = (x - x.mean())/x.std()</span></span>
<span id="cb3-15"><a href="#cb3-15"></a><span class="co">#y = (y - y.mean())/y.std()</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a>_, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>,<span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">4</span>))</span>
<span id="cb4-2"><a href="#cb4-2"></a>ax[<span class="dv">0</span>].plot(x, y, <span class="st">'C0.'</span>)</span>
<span id="cb4-3"><a href="#cb4-3"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="st">'$x$'</span>, fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb4-4"><a href="#cb4-4"></a>ax[<span class="dv">0</span>].set_ylabel(<span class="st">'$y$'</span>, fontsize<span class="op">=</span><span class="dv">16</span>, rotation<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb4-5"><a href="#cb4-5"></a>ax[<span class="dv">0</span>].plot(x, y_real, <span class="st">'k'</span>)</span>
<span id="cb4-6"><a href="#cb4-6"></a>az.plot_kde(y, ax<span class="op">=</span>ax[<span class="dv">1</span>], rug<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb4-7"><a href="#cb4-7"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="st">'$y$'</span>, fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb4-8"><a href="#cb4-8"></a>plt.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>/tmp/ipykernel_6459/2728887943.py:8: UserWarning: This figure was using constrained_layout, but that is incompatible with subplots_adjust and/or tight_layout; disabling constrained_layout.
  plt.tight_layout()</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="05_Regresión_lineal_files/figure-html/cell-5-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>Escribir este modelo en PyMC es bastante directo, la única diferencia con los modelos anteriores es que ahora hemos especificado a la variable <span class="math inline">\(\mu\)</span> como una variable determinista. Una variable determinista tendrá una distribución <em>a posteriori</em> ya que es función de al menos una variable estocástica. Si en PyMC especificamos un variable como determinista esta será incluida en el <code>idata</code>. Alternativamente podríamos haber escrito:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a>μ <span class="op">=</span> α <span class="op">+</span> β <span class="op">*</span> x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Esto es igualmente válido, la única diferencia es que en este caso la variable <span class="math inline">\(\mu\)</span> no estaría incluida en el <code>trace</code></p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> model_g:</span>
<span id="cb7-2"><a href="#cb7-2"></a>    α <span class="op">=</span> pm.Normal(<span class="st">'α'</span>, mu<span class="op">=</span><span class="dv">0</span>, sigma<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb7-3"><a href="#cb7-3"></a>    β <span class="op">=</span> pm.Normal(<span class="st">'β'</span>, mu<span class="op">=</span><span class="dv">0</span>, sigma<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb7-4"><a href="#cb7-4"></a></span>
<span id="cb7-5"><a href="#cb7-5"></a>    ϵ <span class="op">=</span> pm.HalfCauchy(<span class="st">'ϵ'</span>, <span class="dv">5</span>)</span>
<span id="cb7-6"><a href="#cb7-6"></a>    μ <span class="op">=</span> pm.Deterministic(<span class="st">'μ'</span>, α <span class="op">+</span> β <span class="op">*</span> x)</span>
<span id="cb7-7"><a href="#cb7-7"></a>    y_pred <span class="op">=</span> pm.Normal(<span class="st">'y_pred'</span>, mu<span class="op">=</span>μ, sigma<span class="op">=</span>ϵ, observed<span class="op">=</span>y)</span>
<span id="cb7-8"><a href="#cb7-8"></a></span>
<span id="cb7-9"><a href="#cb7-9"></a>    idata_g <span class="op">=</span> pm.sample(<span class="dv">2000</span>, tune<span class="op">=</span><span class="dv">1000</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (4 chains in 4 jobs)
NUTS: [α, β, ϵ]</code></pre>
</div>
<div class="cell-output cell-output-display">

<style>
    /* Turns off some styling */
    progress {
        /* gets rid of default border in Firefox and Opera. */
        border: none;
        /* Needs to be in here for Safari polyfill so background images work as expected. */
        background-size: auto;
    }
    progress:not([value]), progress:not([value])::-webkit-progress-bar {
        background: repeating-linear-gradient(45deg, #7e7e7e, #7e7e7e 10px, #5c5c5c 10px, #5c5c5c 20px);
    }
    .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
        background: #F44336;
    }
</style>
</div>
<div class="cell-output cell-output-display">

    <div>
      <progress value="12000" class="" max="12000" style="width:300px; height:20px; vertical-align: middle;"></progress>
      100.00% [12000/12000 00:10&lt;00:00 Sampling 4 chains, 0 divergences]
    </div>
    
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Sampling 4 chains for 1_000 tune and 2_000 draw iterations (4_000 + 8_000 draws total) took 11 seconds.</code></pre>
</div>
</div>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1"></a>az.plot_trace(idata_g, var_names<span class="op">=</span><span class="st">'~μ'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="05_Regresión_lineal_files/figure-html/cell-7-output-1.png" class="img-fluid"></p>
</div>
</div>
<section id="modelos-lineales-y-autocorrelación" class="level2" data-number="7.1">
<h2 data-number="7.1" class="anchored" data-anchor-id="modelos-lineales-y-autocorrelación"><span class="header-section-number">7.1</span> Modelos lineales y autocorrelación</h2>
<p>En un modelo lineal los parámetros <span class="math inline">\(\alpha\)</span> y <span class="math inline">\(\beta\)</span> están correlacionados. Esto se puede ver en la siguiente figura:</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1"></a>az.plot_pair(idata_g, var_names<span class="op">=</span><span class="st">'~μ'</span>, scatter_kwargs<span class="op">=</span>{<span class="st">'alpha'</span>:<span class="fl">0.5</span>})<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="05_Regresión_lineal_files/figure-html/cell-8-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Esta correlación es una consecuencia directa de nuestras suposiciones. En general al hacer una regresión lineal Bayesiana las lineas que ajustan los datos pasan aproximadamente por la media de <span class="math inline">\(X\)</span> y la media de <span class="math inline">\(Y\)</span>, además el aumento en la pendiente significa la disminución de la ordenada al origen y viceversa. Esto provoca que el posterior para <span class="math inline">\(\alpha\)</span> y <span class="math inline">\(\beta\)</span> sea <em>un espacio muy diagonal</em>. Esto puede ser problemático para métodos como Metropolis-Hastings y, en menor medida para NUTS.</p>
<p>Un método simple para eliminar la correlación entre <span class="math inline">\(\alpha\)</span> y <span class="math inline">\(\beta\)</span> consiste en centrar la variable <span class="math inline">\(X\)</span>, para esto calculamos su media y se la restamos a cada valor, obteniendo así <span class="math inline">\(x'\)</span>. Como resultado la media de <span class="math inline">\(x'\)</span> será 0, si usamos <span class="math inline">\(x'\)</span> como variable dependiente <span class="math inline">\(\alpha\)</span> deberá estar alrededor de 0 y además las lineas que sean solución al problema <em>pivotearán</em> alrededor de 0 por lo que los cambios de <span class="math inline">\(\beta\)</span> tendrán poco efecto en los valores de <span class="math inline">\(\alpha\)</span> esto provoca que el posterior para <span class="math inline">\(\alpha\)</span> y <span class="math inline">\(\beta\)</span> sea <em>más circular</em> y menos correlacionado. Esto lo pueden comprobar ustedes mismos si vuelven a correr el modelo anterior, pero esta vez centrando los datos.</p>
<p>Centrar datos no es solo un truco computacional, también puede ser un truco estadístico que ayuda a interpretar los resultados. <span class="math inline">\(\alpha\)</span> es el valor de $y_i $ cuando <span class="math inline">\(x_i = 0\)</span>. Para muchos problemas, esta interpretación no tiene ningún sentido. Por ejemplo, para cantidades tales como la altura o el peso, los valores de cero no tienen sentido. En cambio, al centrar las variables, <span class="math inline">\(\alpha\)</span> se convierte en el valor de <span class="math inline">\(y_i\)</span> para el valor medio de <span class="math inline">\(x\)</span>. Para algunos problemas, puede ser útil estimar <span class="math inline">\(\alpha\)</span> precisamente porque no es factible medir experimentalmente el valor de <span class="math inline">\(x_i = 0\)</span> y, por lo tanto, <span class="math inline">\(\alpha\)</span> puede proporcionarnos información valiosa, pero las extrapolaciones tienen sus advertencias, así que ¡tene cuidado cuando haces esto!</p>
<p>Es posible que deseemos informar los parámetros estimados en términos de los datos centrados o en términos de datos <em>descentrados</em>, la decisión dependerá del problema y de la audiencia. Si necesitamos informar los parámetros como si hubiesen sido determinados en la escala original, podemos hacer lo siguiente para devolverlos a esa escala:</p>
<p><span class="math display">\[\alpha = \alpha' - \beta' \bar x \tag{3.5}\]</span></p>
<p>Esta corrección es el resultado del siguiente razonamiento algebraico:</p>
<p><span class="math display">\[
y =\alpha' + \beta'x' + \epsilon \\
y =\alpha' + \beta'(x - \bar x) + \epsilon \\
y =\alpha' - \beta' \bar x + \beta'  x + \epsilon \\ \tag{3.6}
\]</span></p>
<p>Luego se deduce que la ecuación 3.5 es verdadera y también:</p>
<p><span class="math display">\[\beta = \beta' \tag{3.7}\]</span></p>
<p>Otra transformación que puede ser útil es estandarizar los datos. Esta transformación es una práctica común para los modelos de regresión lineal tanto en estadística y <em>machine learning</em>, ya que muchos algoritmos se comportan mejor cuando los datos están estandarizados. Esta transformación se logra al centrar los datos y dividirlos por la desviación estándar. Matemáticamente tenemos:</p>
<p><span class="math display">\[
x' = \frac{x - \bar x}{x_{sd}} \\
y' = \frac{y - \bar y}{y_{sd}} \tag{3.8}
\]</span></p>
<p>Una ventaja de la estandarización de los datos es que siempre podemos usar los mismos priors débilmente informativos, sin tener que pensar en la escala de los datos. Para datos estandarizados, la intersección siempre será alrededor de 0 y la pendiente estará restringida al intervalo [-1, 1]. Estandarizar los datos nos permite hablar en términos de Z-score, es decir, en unidades de desviaciones estándar. Si alguien dice que el valor de un parámetro es -1.3 unidades de Z-score, sabemos automáticamente que el valor en cuestión es 1.3 desviaciones estándar por debajo del valor de la media (aún cuando no sepamos cual es el valor de la media). Un cambio en una unidad Z-score es un cambio en una desviación estándar cualquiera sea la escala original de los datos. Los Z-zcore también son muy útiles cuando se trabaja con muchas variables; ya que tener todas las variables en una misma escala puede simplificar la interpretación de los datos.</p>
</section>
<section id="interpretando-y-visualizando-el-posterior" class="level2" data-number="7.2">
<h2 data-number="7.2" class="anchored" data-anchor-id="interpretando-y-visualizando-el-posterior"><span class="header-section-number">7.2</span> Interpretando y visualizando el posterior</h2>
<p>Como ya hemos visto, podemos explorar el posterior usando funciones de ArviZ como <code>plot_trace</code> y <code>summary</code>, o podemos usar nuestras propias funciones. Para una regresión lineal, podría ser útil dibujar la línea promedio que ajusta los datos junto con los valores promedio de <span class="math inline">\(\alpha\)</span> y <span class="math inline">\(\beta\)</span>. Para reflejar la incertidumbre contenida en la distribución <em>a posteriori</em>, podemos usar líneas semitransparentes muestreadas de esta distribución:</p>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1"></a>plt.plot(x, y, <span class="st">'C0.'</span>)</span>
<span id="cb12-2"><a href="#cb12-2"></a></span>
<span id="cb12-3"><a href="#cb12-3"></a></span>
<span id="cb12-4"><a href="#cb12-4"></a>α_m <span class="op">=</span> idata_g.posterior[<span class="st">'α'</span>].mean((<span class="st">"chain"</span>, <span class="st">"draw"</span>)).item()</span>
<span id="cb12-5"><a href="#cb12-5"></a>β_m <span class="op">=</span> idata_g.posterior[<span class="st">'β'</span>].mean((<span class="st">"chain"</span>, <span class="st">"draw"</span>)).item()</span>
<span id="cb12-6"><a href="#cb12-6"></a></span>
<span id="cb12-7"><a href="#cb12-7"></a>few_samples <span class="op">=</span> az.extract(idata_g, num_samples<span class="op">=</span><span class="dv">50</span>)</span>
<span id="cb12-8"><a href="#cb12-8"></a>plt.plot(x, few_samples[<span class="st">'α'</span>].values <span class="op">+</span> few_samples[<span class="st">'β'</span>].values <span class="op">*</span>  x[:,np.newaxis], c<span class="op">=</span><span class="st">'C1'</span>, alpha<span class="op">=</span><span class="fl">0.25</span>)<span class="op">;</span></span>
<span id="cb12-9"><a href="#cb12-9"></a></span>
<span id="cb12-10"><a href="#cb12-10"></a>plt.plot(x, α_m <span class="op">+</span> β_m <span class="op">*</span> x, c<span class="op">=</span><span class="st">'k'</span>,</span>
<span id="cb12-11"><a href="#cb12-11"></a>         label<span class="op">=</span><span class="ss">f'y = </span><span class="sc">{α</span>_m<span class="sc">:.2f}</span><span class="ss"> + </span><span class="sc">{β</span>_m<span class="sc">:.2f}</span><span class="ss"> * x'</span>)</span>
<span id="cb12-12"><a href="#cb12-12"></a></span>
<span id="cb12-13"><a href="#cb12-13"></a>plt.xlabel(<span class="st">'x'</span>)</span>
<span id="cb12-14"><a href="#cb12-14"></a>plt.ylabel(<span class="st">'y'</span>, rotation<span class="op">=</span><span class="dv">0</span>, labelpad<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb12-15"><a href="#cb12-15"></a>plt.legend()<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="05_Regresión_lineal_files/figure-html/cell-9-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>En la figura anterior se puede ver que la incertidumbre es menor en el medio, aunque no se reduce a un solo punto, es decir, la distribución a posteriori es compatible con las líneas que no pasan exactamente por la media de los datos, como ya hemos mencionado.</p>
<p>Una alternativa a muestrear lineas de la distribución a posteriori es dibujar una banda semitransparente que represente un intervalo HDI de <span class="math inline">\(\mu\)</span>. Al haber definido la variable <span class="math inline">\(\mu\)</span> como determinista en el modelo, podemos hacer esto de forma sencilla:</p>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1"></a>plt.plot(x, y, <span class="st">'C0.'</span>)</span>
<span id="cb13-2"><a href="#cb13-2"></a></span>
<span id="cb13-3"><a href="#cb13-3"></a>plt.plot(x, α_m <span class="op">+</span> β_m <span class="op">*</span> x, c<span class="op">=</span><span class="st">'k'</span>,</span>
<span id="cb13-4"><a href="#cb13-4"></a>         label<span class="op">=</span><span class="st">'y = </span><span class="sc">{:.2f}</span><span class="st"> + </span><span class="sc">{:.2f}</span><span class="st"> * x'</span>.<span class="bu">format</span>(α_m, β_m))</span>
<span id="cb13-5"><a href="#cb13-5"></a></span>
<span id="cb13-6"><a href="#cb13-6"></a>az.plot_hdi(x, idata_g.posterior[<span class="st">'μ'</span>], color<span class="op">=</span><span class="st">'C1'</span>)</span>
<span id="cb13-7"><a href="#cb13-7"></a></span>
<span id="cb13-8"><a href="#cb13-8"></a>plt.xlabel(<span class="st">'x'</span>)</span>
<span id="cb13-9"><a href="#cb13-9"></a>plt.ylabel(<span class="st">'y'</span>, rotation<span class="op">=</span><span class="dv">0</span>, labelpad<span class="op">=</span><span class="dv">10</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="05_Regresión_lineal_files/figure-html/cell-10-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Una tercera opción es representar el HDI de la distribución predictiva a posteriori, es decir la distribución de datos predichos. En la siguiente figura sea usa un gris más oscuro para el HDI 50% y un gris más claro para el HDI 94%. Para poder hacer el siguiente gráfico necesitamos, primero, obtener las muestras predictivas posteriores. Lo cual es fácil usando PyMC con la función <code>sample_ppc</code>:</p>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1"></a>idata_g.extend(pm.sample_posterior_predictive(idata_g, model<span class="op">=</span>model_g))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Sampling: [y_pred]</code></pre>
</div>
<div class="cell-output cell-output-display">

<style>
    /* Turns off some styling */
    progress {
        /* gets rid of default border in Firefox and Opera. */
        border: none;
        /* Needs to be in here for Safari polyfill so background images work as expected. */
        background-size: auto;
    }
    progress:not([value]), progress:not([value])::-webkit-progress-bar {
        background: repeating-linear-gradient(45deg, #7e7e7e, #7e7e7e 10px, #5c5c5c 10px, #5c5c5c 20px);
    }
    .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
        background: #F44336;
    }
</style>
</div>
<div class="cell-output cell-output-display">

    <div>
      <progress value="8000" class="" max="8000" style="width:300px; height:20px; vertical-align: middle;"></progress>
      100.00% [8000/8000 00:00&lt;00:00]
    </div>
    
</div>
</div>
<p>Y ahora si la figura</p>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1"></a>plt.plot(x, y, <span class="st">'b.'</span>)</span>
<span id="cb16-2"><a href="#cb16-2"></a>plt.plot(x, α_m <span class="op">+</span> β_m <span class="op">*</span> x, c<span class="op">=</span><span class="st">'k'</span>, label<span class="op">=</span><span class="st">'y = </span><span class="sc">{:.2f}</span><span class="st"> + </span><span class="sc">{:.2f}</span><span class="st"> * x'</span>.<span class="bu">format</span>(α_m, β_m))</span>
<span id="cb16-3"><a href="#cb16-3"></a></span>
<span id="cb16-4"><a href="#cb16-4"></a>az.plot_hdi(x, idata_g.posterior_predictive[<span class="st">'y_pred'</span>], color<span class="op">=</span><span class="st">'C1'</span>)</span>
<span id="cb16-5"><a href="#cb16-5"></a>az.plot_hdi(x, idata_g.posterior_predictive[<span class="st">'y_pred'</span>], hdi_prob<span class="op">=</span><span class="fl">0.5</span>, color<span class="op">=</span><span class="st">'C1'</span>)</span>
<span id="cb16-6"><a href="#cb16-6"></a></span>
<span id="cb16-7"><a href="#cb16-7"></a>plt.xlabel(<span class="st">'x'</span>)</span>
<span id="cb16-8"><a href="#cb16-8"></a>plt.ylabel(<span class="st">'y'</span>, rotation<span class="op">=</span><span class="dv">0</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="05_Regresión_lineal_files/figure-html/cell-12-output-1.png" class="img-fluid"></p>
</div>
</div>
</section>
<section id="regresión-lineal-robusta" class="level2" data-number="7.3">
<h2 data-number="7.3" class="anchored" data-anchor-id="regresión-lineal-robusta"><span class="header-section-number">7.3</span> Regresión lineal robusta</h2>
<p>Asumir que los datos siguen una distribución gaussiana es perfectamente razonable en muchas situaciones. Al asumir Gaussianidad, no necesariamente estamos aceptando que los datos son gaussianos; en cambio, estamos diciendo que es una aproximación razonable para un problema determinado. Como vimos en el capítulo anterior, a veces esta suposición gaussiana falla, por ejemplo, en presencia de valores aberrantes. Aprendimos que el uso de la distribución t de Student es una forma de tratar de manera efectiva con valores atípicos y obtener una inferencia más robusta. La misma idea se puede aplicar a la regresión lineal y para ejemplificarla vamos a utilizar un conjunto de datos muy simple: el tercer grupo de datos del <a href="https://en.wikipedia.org/wiki/Anscombe%27s_quartet">cuarteto de Anscombe</a></p>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1"></a>ans <span class="op">=</span> pd.read_csv(<span class="st">'datos/anscombe.csv'</span>)</span>
<span id="cb17-2"><a href="#cb17-2"></a>x_3 <span class="op">=</span> ans[ans.group <span class="op">==</span> <span class="st">'III'</span>][<span class="st">'x'</span>].values</span>
<span id="cb17-3"><a href="#cb17-3"></a>y_3 <span class="op">=</span> ans[ans.group <span class="op">==</span> <span class="st">'III'</span>][<span class="st">'y'</span>].values</span>
<span id="cb17-4"><a href="#cb17-4"></a>x_3 <span class="op">=</span> x_3 <span class="op">-</span> x_3.mean()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Y ahora veamos cómo luce este pequeño conjunto de datos:</p>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1"></a>_, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>,<span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">5</span>), sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb18-2"><a href="#cb18-2"></a></span>
<span id="cb18-3"><a href="#cb18-3"></a>ax[<span class="dv">0</span>].plot(x_3, y_3, <span class="st">'C0o'</span>)</span>
<span id="cb18-4"><a href="#cb18-4"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="st">'x'</span>)</span>
<span id="cb18-5"><a href="#cb18-5"></a>ax[<span class="dv">0</span>].set_ylabel(<span class="st">'y'</span>, rotation<span class="op">=</span><span class="dv">0</span>, labelpad<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb18-6"><a href="#cb18-6"></a>ax[<span class="dv">1</span>].set_xticks([])</span>
<span id="cb18-7"><a href="#cb18-7"></a>az.plot_kde(y_3, ax<span class="op">=</span>ax[<span class="dv">1</span>], rug<span class="op">=</span><span class="va">True</span>, rotated<span class="op">=</span><span class="va">True</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="05_Regresión_lineal_files/figure-html/cell-14-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Ahora vamos a reescribir el <code>modelo_g</code> esta vez usando una distribución t de Student en lugar de una Gaussiana. Este cambio también introduce la necesidad de especificar el valor de <span class="math inline">\(\nu\)</span>, el parámetro de normalidad. Si no recuerdas la función de este parámetro, consultá el capítulo anterior antes de continuar.</p>
<p>En el siguiente modelo estamos usando una distribución exponencial <em>desplazada</em>, para evitar valores de <span class="math inline">\(\nu\)</span> cercanos a cero. La exponencial <em>no desplazada</em> pone demasiado peso en valores cercanos a cero y esto puede traer algunos problemas. En el casos del tercer conjunto de datos de Anscombe <em>lo problemático</em> deriva de que es posible ajustar una recta de forma perfecta (si obviamos el dato aberrante). Como regla general los <em>priors</em> usados en este curso suelen ser buenos valores por defecto, pero nada más que eso. Otra distribución a <em>priori</em> comunmente usada para <span class="math inline">\(\nu\)</span> es <code>gamma(2, 0.1)</code> o <code>gamma(mu=20, sd=15)</code>.</p>
<div class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> model_t:</span>
<span id="cb19-2"><a href="#cb19-2"></a>    α <span class="op">=</span> pm.Normal(<span class="st">'α'</span>, y_3.mean(), <span class="dv">1</span>)</span>
<span id="cb19-3"><a href="#cb19-3"></a>    β <span class="op">=</span> pm.Normal(<span class="st">'β'</span>, <span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb19-4"><a href="#cb19-4"></a>    ϵ <span class="op">=</span> pm.HalfNormal(<span class="st">'ϵ'</span>, <span class="dv">5</span>)</span>
<span id="cb19-5"><a href="#cb19-5"></a>    ν_ <span class="op">=</span> pm.Exponential(<span class="st">'ν_'</span>, <span class="dv">1</span><span class="op">/</span><span class="dv">29</span>)</span>
<span id="cb19-6"><a href="#cb19-6"></a>    ν <span class="op">=</span> pm.Deterministic(<span class="st">'ν'</span>, ν_ <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb19-7"><a href="#cb19-7"></a>    </span>
<span id="cb19-8"><a href="#cb19-8"></a>    y_pred <span class="op">=</span> pm.StudentT(<span class="st">'y_pred'</span>, mu<span class="op">=</span>α <span class="op">+</span> β <span class="op">*</span> x_3,</span>
<span id="cb19-9"><a href="#cb19-9"></a>                         sigma<span class="op">=</span>ϵ, nu<span class="op">=</span>ν, observed<span class="op">=</span>y_3)</span>
<span id="cb19-10"><a href="#cb19-10"></a>    </span>
<span id="cb19-11"><a href="#cb19-11"></a>    idata_t <span class="op">=</span> pm.sample(<span class="dv">2000</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (4 chains in 4 jobs)
NUTS: [α, β, ϵ, ν_]</code></pre>
</div>
<div class="cell-output cell-output-display">

<style>
    /* Turns off some styling */
    progress {
        /* gets rid of default border in Firefox and Opera. */
        border: none;
        /* Needs to be in here for Safari polyfill so background images work as expected. */
        background-size: auto;
    }
    progress:not([value]), progress:not([value])::-webkit-progress-bar {
        background: repeating-linear-gradient(45deg, #7e7e7e, #7e7e7e 10px, #5c5c5c 10px, #5c5c5c 20px);
    }
    .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
        background: #F44336;
    }
</style>
</div>
<div class="cell-output cell-output-display">

    <div>
      <progress value="12000" class="" max="12000" style="width:300px; height:20px; vertical-align: middle;"></progress>
      100.00% [12000/12000 00:05&lt;00:00 Sampling 4 chains, 0 divergences]
    </div>
    
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Sampling 4 chains for 1_000 tune and 2_000 draw iterations (4_000 + 8_000 draws total) took 6 seconds.</code></pre>
</div>
</div>
<div class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1"></a>var_names <span class="op">=</span> [<span class="st">'~ν_'</span>]</span>
<span id="cb22-2"><a href="#cb22-2"></a>az.plot_trace(idata_t, var_names<span class="op">=</span>var_names, kind<span class="op">=</span><span class="st">"rank_vlines"</span>, combined<span class="op">=</span><span class="va">True</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="05_Regresión_lineal_files/figure-html/cell-16-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>En la siguiente gráfica podemos ver el ajuste robusto, según <code>model_t</code>, y el ajuste no robusto de acuerdo con la función <code>linregress</code> de SciPy (esta función realiza una regresión por mínimos cuadrados). Como ejercicio, puede intentar agregar a esta gráfica la mejor línea obtenida usando <code>model_g</code>.</p>
<div class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1"></a>beta_c, alpha_c <span class="op">=</span> stats.linregress(x_3, y_3)[:<span class="dv">2</span>]</span>
<span id="cb23-2"><a href="#cb23-2"></a></span>
<span id="cb23-3"><a href="#cb23-3"></a>plt.plot(x_3, (alpha_c <span class="op">+</span> beta_c <span class="op">*</span> x_3), label<span class="op">=</span><span class="st">'no-robusto'</span>)</span>
<span id="cb23-4"><a href="#cb23-4"></a>plt.plot(x_3, y_3, <span class="st">'ko'</span>)</span>
<span id="cb23-5"><a href="#cb23-5"></a>alpha_m <span class="op">=</span> idata_t.posterior[<span class="st">'α'</span>].mean().item()</span>
<span id="cb23-6"><a href="#cb23-6"></a>beta_m <span class="op">=</span> idata_t.posterior[<span class="st">'β'</span>].mean().item()</span>
<span id="cb23-7"><a href="#cb23-7"></a>plt.plot(x_3, alpha_m <span class="op">+</span> beta_m <span class="op">*</span> x_3, label<span class="op">=</span><span class="st">'robusto'</span>)</span>
<span id="cb23-8"><a href="#cb23-8"></a></span>
<span id="cb23-9"><a href="#cb23-9"></a>plt.xlabel(<span class="st">'x'</span>)</span>
<span id="cb23-10"><a href="#cb23-10"></a>plt.ylabel(<span class="st">'y'</span>, rotation<span class="op">=</span><span class="dv">0</span>, labelpad<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb23-11"><a href="#cb23-11"></a>plt.legend(loc<span class="op">=</span><span class="dv">2</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="05_Regresión_lineal_files/figure-html/cell-17-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>La figura anterior se puede explicar porque una distribución de t, con sus colas más pesadas, es capaz de dar menos importancia a los puntos que están alejados del <em>grupo principal</em> de datos. En cambio el ajuste no robusto <em>se esfuerza</em> por incluir a todos los puntos. SI bien este es un conjunto muy particular de datos el mensaje es válido para datos más complejos y <em>reales</em></p>
<p>Antes de continuar tómese un momento para contemplar los valores de los parámetros (estoy omitiendo los parámetros intermedios ya que no es de interés directo).</p>
<p>Antes de continuar tómemonos un momento para contemplar los valores de los parámetros según la distribución a posteriori.</p>
<div class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1"></a>az.summary(idata_t, var_names)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="17">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>mean</th>
      <th>sd</th>
      <th>hdi_3%</th>
      <th>hdi_97%</th>
      <th>mcse_mean</th>
      <th>mcse_sd</th>
      <th>ess_bulk</th>
      <th>ess_tail</th>
      <th>r_hat</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>α</th>
      <td>7.114</td>
      <td>0.001</td>
      <td>7.112</td>
      <td>7.117</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>5019.0</td>
      <td>4365.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>β</th>
      <td>0.345</td>
      <td>0.000</td>
      <td>0.345</td>
      <td>0.346</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>4709.0</td>
      <td>3331.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>ϵ</th>
      <td>0.003</td>
      <td>0.002</td>
      <td>0.001</td>
      <td>0.006</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>1527.0</td>
      <td>581.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>ν</th>
      <td>1.205</td>
      <td>0.199</td>
      <td>1.000</td>
      <td>1.581</td>
      <td>0.003</td>
      <td>0.002</td>
      <td>1752.0</td>
      <td>614.0</td>
      <td>1.0</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>Como pueden ver, los valores de <span class="math inline">\(\alpha\)</span>, <span class="math inline">\(\beta\)</span> y <span class="math inline">\(\epsilon\)</span> practicamente no tienen variación (sd=0), incluso <span class="math inline">\(\epsilon\)</span> es prácticamente 0. Esto es totalmente razonable dado que estamos ajustando una línea recta a un perfecto conjunto alineado de puntos (si ignoramos el punto atípico).</p>
</section>
<section id="regresión-lineal-jerárquica" class="level2" data-number="7.4">
<h2 data-number="7.4" class="anchored" data-anchor-id="regresión-lineal-jerárquica"><span class="header-section-number">7.4</span> Regresión lineal jerárquica</h2>
<p>En el capítulo anterior, aprendimos los rudimentos de los modelos jerárquicos. Este mismo concepto se puede aplicar a las regresiones lineales. Esto permite que los modelos realicen inferencias a nivel de subgrupo y a nivel global. Como ya vimos, esto se hace incluyendo hiperpriors.</p>
<p>Vamos a crear ocho grupos de datos relacionados, incluido uno con un solo dato</p>
<div class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1"></a>N <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb25-2"><a href="#cb25-2"></a>M <span class="op">=</span> <span class="dv">8</span></span>
<span id="cb25-3"><a href="#cb25-3"></a>idx <span class="op">=</span> np.repeat(<span class="bu">range</span>(M<span class="op">-</span><span class="dv">1</span>), N)</span>
<span id="cb25-4"><a href="#cb25-4"></a>idx <span class="op">=</span> np.append(idx, <span class="dv">7</span>)</span>
<span id="cb25-5"><a href="#cb25-5"></a>np.random.seed(<span class="dv">314</span>)</span>
<span id="cb25-6"><a href="#cb25-6"></a></span>
<span id="cb25-7"><a href="#cb25-7"></a>alfa_real <span class="op">=</span> np.random.normal(<span class="fl">2.5</span>, <span class="fl">0.5</span>, size<span class="op">=</span>M)</span>
<span id="cb25-8"><a href="#cb25-8"></a>beta_real <span class="op">=</span> np.random.beta(<span class="dv">6</span>, <span class="dv">1</span>, size<span class="op">=</span>M)</span>
<span id="cb25-9"><a href="#cb25-9"></a>eps_real <span class="op">=</span> np.random.normal(<span class="dv">0</span>, <span class="fl">0.5</span>, size<span class="op">=</span><span class="bu">len</span>(idx))</span>
<span id="cb25-10"><a href="#cb25-10"></a></span>
<span id="cb25-11"><a href="#cb25-11"></a>y_m <span class="op">=</span> np.zeros(<span class="bu">len</span>(idx))</span>
<span id="cb25-12"><a href="#cb25-12"></a>x_m <span class="op">=</span> np.random.normal(<span class="dv">10</span>, <span class="dv">1</span>, <span class="bu">len</span>(idx))</span>
<span id="cb25-13"><a href="#cb25-13"></a>y_m <span class="op">=</span> alfa_real[idx] <span class="op">+</span> beta_real[idx] <span class="op">*</span> x_m  <span class="op">+</span> eps_real</span>
<span id="cb25-14"><a href="#cb25-14"></a></span>
<span id="cb25-15"><a href="#cb25-15"></a>_, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">4</span>, figsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">5</span>), sharex<span class="op">=</span><span class="va">True</span>, sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb25-16"><a href="#cb25-16"></a>ax <span class="op">=</span> np.ravel(ax)</span>
<span id="cb25-17"><a href="#cb25-17"></a>j, k <span class="op">=</span> <span class="dv">0</span>, N</span>
<span id="cb25-18"><a href="#cb25-18"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(M):</span>
<span id="cb25-19"><a href="#cb25-19"></a>    ax[i].scatter(x_m[j:k], y_m[j:k])</span>
<span id="cb25-20"><a href="#cb25-20"></a>    ax[i].set_xlabel(<span class="st">'$x_</span><span class="sc">{}</span><span class="st">$'</span>.<span class="bu">format</span>(i))</span>
<span id="cb25-21"><a href="#cb25-21"></a>    ax[i].set_ylabel(<span class="st">'$y_</span><span class="sc">{}</span><span class="st">$'</span>.<span class="bu">format</span>(i), rotation<span class="op">=</span><span class="dv">0</span>, labelpad<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb25-22"><a href="#cb25-22"></a>    ax[i].set_xlim(<span class="dv">6</span>, <span class="dv">15</span>)</span>
<span id="cb25-23"><a href="#cb25-23"></a>    ax[i].set_ylim(<span class="dv">7</span>, <span class="dv">17</span>)</span>
<span id="cb25-24"><a href="#cb25-24"></a>    j <span class="op">+=</span> N</span>
<span id="cb25-25"><a href="#cb25-25"></a>    k <span class="op">+=</span> N</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="05_Regresión_lineal_files/figure-html/cell-19-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Vamos a centrar los datos antes de pasárselos al modelo.</p>
<div class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1"></a>x_centered <span class="op">=</span> x_m <span class="op">-</span> x_m.mean()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> hierarchical_model:</span>
<span id="cb27-2"><a href="#cb27-2"></a>    <span class="co"># hyper-priors</span></span>
<span id="cb27-3"><a href="#cb27-3"></a>    α_μ_tmp <span class="op">=</span> pm.Normal(<span class="st">'α_μ_tmp'</span>, mu<span class="op">=</span><span class="dv">0</span>, sigma<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb27-4"><a href="#cb27-4"></a>    α_σ_tmp <span class="op">=</span> pm.HalfNormal(<span class="st">'α_σ_tmp'</span>, <span class="dv">10</span>)</span>
<span id="cb27-5"><a href="#cb27-5"></a>    β_μ <span class="op">=</span> pm.Normal(<span class="st">'β_μ'</span>, mu<span class="op">=</span><span class="dv">0</span>, sigma<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb27-6"><a href="#cb27-6"></a>    β_σ <span class="op">=</span> pm.HalfNormal(<span class="st">'β_σ'</span>, sigma<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb27-7"><a href="#cb27-7"></a></span>
<span id="cb27-8"><a href="#cb27-8"></a>    <span class="co"># priors</span></span>
<span id="cb27-9"><a href="#cb27-9"></a>    α_tmp <span class="op">=</span> pm.Normal(<span class="st">'α_tmp'</span>, mu<span class="op">=</span>α_μ_tmp, sigma<span class="op">=</span>α_σ_tmp, shape<span class="op">=</span>M)</span>
<span id="cb27-10"><a href="#cb27-10"></a>    β <span class="op">=</span> pm.Normal(<span class="st">'β'</span>, mu<span class="op">=</span>β_μ, sigma<span class="op">=</span>β_σ, shape<span class="op">=</span>M)</span>
<span id="cb27-11"><a href="#cb27-11"></a>    ϵ <span class="op">=</span> pm.HalfCauchy(<span class="st">'ϵ'</span>, <span class="dv">5</span>)</span>
<span id="cb27-12"><a href="#cb27-12"></a>    ν <span class="op">=</span> pm.Exponential(<span class="st">'ν'</span>, <span class="dv">1</span><span class="op">/</span><span class="dv">30</span>)</span>
<span id="cb27-13"><a href="#cb27-13"></a></span>
<span id="cb27-14"><a href="#cb27-14"></a>    y_pred <span class="op">=</span> pm.StudentT(<span class="st">'y_pred'</span>, mu<span class="op">=</span>α_tmp[idx] <span class="op">+</span> β[idx] <span class="op">*</span> x_centered, sigma<span class="op">=</span>ϵ, nu<span class="op">=</span>ν, observed<span class="op">=</span>y_m)</span>
<span id="cb27-15"><a href="#cb27-15"></a></span>
<span id="cb27-16"><a href="#cb27-16"></a>    α <span class="op">=</span> pm.Deterministic(<span class="st">'α'</span>, α_tmp <span class="op">-</span> β <span class="op">*</span> x_m.mean()) </span>
<span id="cb27-17"><a href="#cb27-17"></a></span>
<span id="cb27-18"><a href="#cb27-18"></a>    idata_hm <span class="op">=</span> pm.sample(<span class="dv">1000</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (4 chains in 4 jobs)
NUTS: [α_μ_tmp, α_σ_tmp, β_μ, β_σ, α_tmp, β, ϵ, ν]</code></pre>
</div>
<div class="cell-output cell-output-display">

<style>
    /* Turns off some styling */
    progress {
        /* gets rid of default border in Firefox and Opera. */
        border: none;
        /* Needs to be in here for Safari polyfill so background images work as expected. */
        background-size: auto;
    }
    progress:not([value]), progress:not([value])::-webkit-progress-bar {
        background: repeating-linear-gradient(45deg, #7e7e7e, #7e7e7e 10px, #5c5c5c 10px, #5c5c5c 20px);
    }
    .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
        background: #F44336;
    }
</style>
</div>
<div class="cell-output cell-output-display">

    <div>
      <progress value="8000" class="" max="8000" style="width:300px; height:20px; vertical-align: middle;"></progress>
      100.00% [8000/8000 00:08&lt;00:00 Sampling 4 chains, 127 divergences]
    </div>
    
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Sampling 4 chains for 1_000 tune and 1_000 draw iterations (4_000 + 4_000 draws total) took 9 seconds.</code></pre>
</div>
</div>
<div class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1"></a>az.plot_forest(idata_hm, var_names<span class="op">=</span>[<span class="st">'α'</span>, <span class="st">'β'</span>], figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">4</span>), combined<span class="op">=</span><span class="va">True</span>, r_hat<span class="op">=</span><span class="va">False</span>, ess<span class="op">=</span><span class="va">False</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="05_Regresión_lineal_files/figure-html/cell-22-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Dibujemos las líneas ajustadas, para cada uno de los ocho grupos.</p>
<div class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1"></a>_, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">4</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">4</span>), sharex<span class="op">=</span><span class="va">True</span>, sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb31-2"><a href="#cb31-2"></a>ax <span class="op">=</span> np.ravel(ax)</span>
<span id="cb31-3"><a href="#cb31-3"></a>j, k <span class="op">=</span> <span class="dv">0</span>, N</span>
<span id="cb31-4"><a href="#cb31-4"></a>x_range <span class="op">=</span> np.linspace(x_m.<span class="bu">min</span>(), x_m.<span class="bu">max</span>(), <span class="dv">10</span>)</span>
<span id="cb31-5"><a href="#cb31-5"></a>posterior <span class="op">=</span> az.extract(idata_hm)</span>
<span id="cb31-6"><a href="#cb31-6"></a></span>
<span id="cb31-7"><a href="#cb31-7"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(M):</span>
<span id="cb31-8"><a href="#cb31-8"></a>    ax[i].scatter(x_m[j:k], y_m[j:k])</span>
<span id="cb31-9"><a href="#cb31-9"></a>    ax[i].set_xlabel(<span class="st">'$x_</span><span class="sc">{}</span><span class="st">$'</span>.<span class="bu">format</span>(i))</span>
<span id="cb31-10"><a href="#cb31-10"></a>    ax[i].set_ylabel(<span class="st">'$y_</span><span class="sc">{}</span><span class="st">$'</span>.<span class="bu">format</span>(i), labelpad<span class="op">=</span><span class="dv">10</span>, rotation<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb31-11"><a href="#cb31-11"></a>    alfas <span class="op">=</span> posterior[<span class="st">'α'</span>].sel(α_dim_0<span class="op">=</span>i)</span>
<span id="cb31-12"><a href="#cb31-12"></a>    betas <span class="op">=</span> posterior[<span class="st">'β'</span>].sel(β_dim_0<span class="op">=</span>i)</span>
<span id="cb31-13"><a href="#cb31-13"></a>    alfa_m <span class="op">=</span> alfas.mean(<span class="st">"sample"</span>).item()</span>
<span id="cb31-14"><a href="#cb31-14"></a>    beta_m <span class="op">=</span> betas.mean(<span class="st">"sample"</span>).item()</span>
<span id="cb31-15"><a href="#cb31-15"></a>    ax[i].plot(x_range, alfa_m <span class="op">+</span> beta_m <span class="op">*</span> x_range, c<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb31-16"><a href="#cb31-16"></a>    az.plot_hdi(x_range, alfas <span class="op">+</span> betas <span class="op">*</span> xr.DataArray(x_range).transpose(), ax<span class="op">=</span>ax[i])</span>
<span id="cb31-17"><a href="#cb31-17"></a>    plt.xlim(x_m.<span class="bu">min</span>()<span class="op">-</span><span class="dv">1</span>, x_m.<span class="bu">max</span>()<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb31-18"><a href="#cb31-18"></a>    plt.ylim(y_m.<span class="bu">min</span>()<span class="op">-</span><span class="dv">1</span>, y_m.<span class="bu">max</span>()<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb31-19"><a href="#cb31-19"></a>    j <span class="op">+=</span> N</span>
<span id="cb31-20"><a href="#cb31-20"></a>    k <span class="op">+=</span> N</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="05_Regresión_lineal_files/figure-html/cell-23-output-1.png" class="img-fluid"></p>
</div>
</div>
</section>
<section id="regresión-lineal-multiple" class="level2" data-number="7.5">
<h2 data-number="7.5" class="anchored" data-anchor-id="regresión-lineal-multiple"><span class="header-section-number">7.5</span> Regresión lineal Multiple</h2>
<p>Hasta ahora hemos estado trabajando con una variable dependiente y una variable independiente, sin embargo no es inusual tener varias variables independientes que queremos incluir en nuestro modelo. Algunos ejemplos podrían ser:</p>
<ul>
<li>Calidad percibida del vino (dependiente) y acidez, densidad, nivel de alcohol, azúcar residual y contenido de sulfatos (variables independientes)</li>
<li>Calificaciones promedio de los estudiantes (dependientes) e ingresos familiares, distancia de la casa a la escuela y educación de la madre (variable categórica)</li>
</ul>
<p>Podemos extender fácilmente el modelo de regresión lineal simple para tratar con más de una variable independiente. Llamamos a este modelo regresión lineal múltiple, que no debe confundirse con la regresión lineal multivariada, que corresponde con el caso de múltiples variables dependientes.</p>
<p>En una regresión lineal múltiple modelamos la media de la variable dependiente como:</p>
<p><span class="math display">\[\mu = \alpha + \beta_1 x_1 + \beta_2 x_2 \dots + \beta_m x_m \tag{3.15}\]</span></p>
<p>La expresión 3.15 se parece a una regresión polinomial (ecuación 3.12), pero no es exactamente lo mismo. Para la regresión lineal múltiple tenemos diferentes variables independientes en lugar de potencias sucesivas de la misma variable independiente. Desde el punto de vista de la regresión lineal múltiple, podemos decir que una regresión polinomial es como una regresión lineal múltiple pero con variables <em>inventadas</em>.</p>
<p>Usando la notación de álgebra lineal, podemos escribir una versión más corta:</p>
<p><span class="math display">\[\mu = \alpha + X \beta \tag{3.16}\]</span></p>
<p>Donde <span class="math inline">\(\beta\)</span> es un vector de coeficientes de longitud <span class="math inline">\(m\)</span>, es decir, el número de variables dependientes. La variable <span class="math inline">\(X\)</span> es una matriz de tamaño <span class="math inline">\(m \times n\)</span> si <span class="math inline">\(n\)</span> es el número de observaciones y <span class="math inline">\(m\)</span> es el número de variables independientes. Si estás un poco oxidado con el álgebra lineal, puedes consultar el artículo de Wikipedia sobre el producto escalar entre dos vectores y su generalización a la multiplicación de matrices. Básicamente lo que necesitamos saber por el momento es que estamos usando una forma más corta y conveniente de escribir nuestro modelo:</p>
<p><span class="math display">\[X \beta = \sum_{i=1}^n \beta_ix_i = \beta_1 x_1 + \beta_2 x_2 \dots + \beta_m x_m \tag{3.17} \]</span></p>
<p>Usando el modelo de regresión lineal simple, encontramos una línea recta que (con suerte) explica nuestros datos. Bajo el modelo de regresión lineal múltiple, encontramos, en cambio, un hiperplano de dimensión <span class="math inline">\(m\)</span>. Por lo tanto, el modelo de regresión lineal múltiple es esencialmente el mismo modelo de regresión lineal simple, la única diferencia es que ahora $$ es un vector y <span class="math inline">\(X\)</span> es una matriz.</p>
<p>Vamos a definir nuestros datos:</p>
<div class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1"></a>np.random.seed(<span class="dv">314</span>)</span>
<span id="cb32-2"><a href="#cb32-2"></a>N <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb32-3"><a href="#cb32-3"></a>alpha_real <span class="op">=</span> <span class="fl">2.5</span></span>
<span id="cb32-4"><a href="#cb32-4"></a>beta_real <span class="op">=</span> [<span class="fl">0.9</span>, <span class="fl">1.5</span>]</span>
<span id="cb32-5"><a href="#cb32-5"></a>eps_real <span class="op">=</span> np.random.normal(<span class="dv">0</span>, <span class="fl">0.5</span>, size<span class="op">=</span>N)</span>
<span id="cb32-6"><a href="#cb32-6"></a></span>
<span id="cb32-7"><a href="#cb32-7"></a>X <span class="op">=</span> np.array([np.random.normal(i, j, N) <span class="cf">for</span> i,j <span class="kw">in</span> <span class="bu">zip</span>([<span class="dv">10</span>, <span class="dv">2</span>], [<span class="dv">1</span>, <span class="fl">1.5</span>])]).T</span>
<span id="cb32-8"><a href="#cb32-8"></a>X_mean <span class="op">=</span> X.mean(axis<span class="op">=</span><span class="dv">0</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb32-9"><a href="#cb32-9"></a>X_centered <span class="op">=</span> X <span class="op">-</span> X_mean</span>
<span id="cb32-10"><a href="#cb32-10"></a>y <span class="op">=</span> alpha_real <span class="op">+</span> np.dot(X, beta_real) <span class="op">+</span> eps_real</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>A continuación vamos a definir una función que realiza tres gráficos de dispersión, dos entre cada variable independiente y la variable dependiente y el último entre ambas variables dependientes. Usaremos esta función para ayudarnos durante el resto del capítulo:</p>
<div class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1"></a><span class="kw">def</span> scatter_plot(x, y):</span>
<span id="cb33-2"><a href="#cb33-2"></a>    plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">10</span>))</span>
<span id="cb33-3"><a href="#cb33-3"></a>    <span class="cf">for</span> idx, x_i <span class="kw">in</span> <span class="bu">enumerate</span>(x.T):</span>
<span id="cb33-4"><a href="#cb33-4"></a>        plt.subplot(<span class="dv">2</span>, <span class="dv">2</span>, idx<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb33-5"><a href="#cb33-5"></a>        plt.scatter(x_i, y)</span>
<span id="cb33-6"><a href="#cb33-6"></a>        plt.xlabel(<span class="st">'x_</span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(idx<span class="op">+</span><span class="dv">1</span>))</span>
<span id="cb33-7"><a href="#cb33-7"></a>        plt.ylabel(<span class="st">'y'</span>, rotation<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb33-8"><a href="#cb33-8"></a></span>
<span id="cb33-9"><a href="#cb33-9"></a>    plt.subplot(<span class="dv">2</span>, <span class="dv">2</span>, idx<span class="op">+</span><span class="dv">2</span>)</span>
<span id="cb33-10"><a href="#cb33-10"></a>    plt.scatter(x[:,<span class="dv">0</span>], x[:,<span class="dv">1</span>])</span>
<span id="cb33-11"><a href="#cb33-11"></a>    plt.xlabel(<span class="st">'x_</span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(idx))</span>
<span id="cb33-12"><a href="#cb33-12"></a>    plt.ylabel(<span class="st">'x_</span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(idx<span class="op">+</span><span class="dv">1</span>), rotation<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb33-13"><a href="#cb33-13"></a></span>
<span id="cb33-14"><a href="#cb33-14"></a>scatter_plot(X_centered, y)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="05_Regresión_lineal_files/figure-html/cell-25-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Ahora sí vamos a definir, en PyMC3, un modelo adecuado para la regresión lineal múltiple. Como es de esperar el código luce muy similar al modelo de regresión lineal simple. Las principales diferencias son:</p>
<ul>
<li>La variable <span class="math inline">\(\beta\)</span> es Gaussiana con <code>shape = 2</code>, es decir una pendiente por cada variable independiente.</li>
<li>La variable <span class="math inline">\(\mu\)</span> la definimos usando la función <code>pm.math.dot()</code></li>
</ul>
<p>Si estás familiarizado con NumPy, probablemente sepas que NumPy también incluye una función para multiplicar matrices <code>np.dot</code> y desde Python 3.5 (y desde NumPy 1.10) existe un nuevo operador para multiplicar matrices <code>@</code>. Sin embargo, aquí usamos la función de PyMC3, que no es más que un alias para el operador de multiplicación de matrices de Theano. Necesitamos hacer esto porque la variable <span class="math inline">\(\beta\)</span> es un tensor de Theano y no un array de NumPy.</p>
<div class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> model_mlr:</span>
<span id="cb34-2"><a href="#cb34-2"></a>    α_tmp <span class="op">=</span> pm.Normal(<span class="st">'α_tmp'</span>, mu<span class="op">=</span><span class="dv">0</span>, sigma<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb34-3"><a href="#cb34-3"></a>    β <span class="op">=</span> pm.Normal(<span class="st">'β'</span>, mu<span class="op">=</span><span class="dv">0</span>, sigma<span class="op">=</span><span class="dv">1</span>, shape<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb34-4"><a href="#cb34-4"></a>    ϵ <span class="op">=</span> pm.HalfCauchy(<span class="st">'ϵ'</span>, <span class="dv">5</span>)</span>
<span id="cb34-5"><a href="#cb34-5"></a></span>
<span id="cb34-6"><a href="#cb34-6"></a>    μ <span class="op">=</span> α_tmp <span class="op">+</span> pm.math.dot(X_centered, β)</span>
<span id="cb34-7"><a href="#cb34-7"></a></span>
<span id="cb34-8"><a href="#cb34-8"></a>    α <span class="op">=</span> pm.Deterministic(<span class="st">'α'</span>, α_tmp <span class="op">-</span> pm.math.dot(X_mean, β)) </span>
<span id="cb34-9"><a href="#cb34-9"></a></span>
<span id="cb34-10"><a href="#cb34-10"></a>    y_pred <span class="op">=</span> pm.Normal(<span class="st">'y_pred'</span>, mu<span class="op">=</span>μ, sigma<span class="op">=</span>ϵ, observed<span class="op">=</span>y)</span>
<span id="cb34-11"><a href="#cb34-11"></a></span>
<span id="cb34-12"><a href="#cb34-12"></a>    trace_mlr <span class="op">=</span> pm.sample(<span class="dv">2000</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (4 chains in 4 jobs)
NUTS: [α_tmp, β, ϵ]</code></pre>
</div>
<div class="cell-output cell-output-display">

<style>
    /* Turns off some styling */
    progress {
        /* gets rid of default border in Firefox and Opera. */
        border: none;
        /* Needs to be in here for Safari polyfill so background images work as expected. */
        background-size: auto;
    }
    progress:not([value]), progress:not([value])::-webkit-progress-bar {
        background: repeating-linear-gradient(45deg, #7e7e7e, #7e7e7e 10px, #5c5c5c 10px, #5c5c5c 20px);
    }
    .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
        background: #F44336;
    }
</style>
</div>
<div class="cell-output cell-output-display">

    <div>
      <progress value="12000" class="" max="12000" style="width:300px; height:20px; vertical-align: middle;"></progress>
      100.00% [12000/12000 00:02&lt;00:00 Sampling 4 chains, 0 divergences]
    </div>
    
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Sampling 4 chains for 1_000 tune and 2_000 draw iterations (4_000 + 8_000 draws total) took 3 seconds.</code></pre>
</div>
</div>
<div class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1"></a>var_names <span class="op">=</span> [<span class="st">'α'</span>, <span class="st">'β'</span>,<span class="st">'ϵ'</span>]</span>
<span id="cb37-2"><a href="#cb37-2"></a>az.plot_trace(trace_mlr, var_names)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="05_Regresión_lineal_files/figure-html/cell-27-output-1.png" class="img-fluid"></p>
</div>
</div>
<div class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1"></a>az.summary(trace_mlr, var_names)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="27">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>mean</th>
      <th>sd</th>
      <th>hdi_3%</th>
      <th>hdi_97%</th>
      <th>mcse_mean</th>
      <th>mcse_sd</th>
      <th>ess_bulk</th>
      <th>ess_tail</th>
      <th>r_hat</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>α[0]</th>
      <td>1.850</td>
      <td>0.452</td>
      <td>1.013</td>
      <td>2.704</td>
      <td>0.004</td>
      <td>0.003</td>
      <td>10727.0</td>
      <td>6419.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>β[0]</th>
      <td>0.969</td>
      <td>0.044</td>
      <td>0.884</td>
      <td>1.047</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>11149.0</td>
      <td>6629.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>β[1]</th>
      <td>1.470</td>
      <td>0.032</td>
      <td>1.414</td>
      <td>1.533</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>12941.0</td>
      <td>6680.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>ϵ</th>
      <td>0.474</td>
      <td>0.034</td>
      <td>0.412</td>
      <td>0.537</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>10672.0</td>
      <td>6604.0</td>
      <td>1.0</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>Como podemos ver, nuestro modelo es capaz de recuperar los valores correctos (verificalo comparando contra los valores utilizados para generar los datos sintéticos).</p>
<p>En las siguientes secciones, nos centraremos en algunas precauciones que debemos tomar al analizar los resultados de un modelo de regresión múltiple, especialmente la interpretación de las pendientes. El principal mensaje de la siguiente sección es que en una regresión lineal múltiple, cada uno de los parámetros solo tiene sentido en el contexto del resto de los parámetros.</p>
</section>
<section id="variables-de-confusión-y-variables-redundantes" class="level2" data-number="7.6">
<h2 data-number="7.6" class="anchored" data-anchor-id="variables-de-confusión-y-variables-redundantes"><span class="header-section-number">7.6</span> Variables de confusión y variables redundantes</h2>
<p>Imagina la siguiente situación. Tenemos una variable <span class="math inline">\(z\)</span> correlacionada con la variable predictora <span class="math inline">\(x\)</span> y, al mismo tiempo, con la variable dependiente <span class="math inline">\(y\)</span>. Supongamos que la variable <span class="math inline">\(z\)</span> es la responsable de causar <span class="math inline">\(x\)</span> e <span class="math inline">\(y\)</span>. Por ejemplo, <span class="math inline">\(z\)</span> podría ser la revolución industrial (¡una variable realmente compleja!), <span class="math inline">\(x\)</span> el número de piratas, e <span class="math inline">\(y\)</span> la concentración de <span class="math inline">\(CO_2\)</span>. Este ejemplo debería ser muy familiar para lectores <a href="https://es.wikipedia.org/wiki/Pastafarismo">Pastafariano</a>. Si omitimos <span class="math inline">\(z\)</span> de nuestro análisis, podríamos terminar con una buena relación lineal entre <span class="math inline">\(x\)</span> e <span class="math inline">\(y\)</span>, incluso podríamos predecir <span class="math inline">\(x\)</span> a partir de <span class="math inline">\(y\)</span>. Sin embargo, si nuestro interés radica en minimizar el calentamiento global, podríamos pasar por alto lo que realmente está sucediendo con el mecanismo subyacente que relaciona estas variables.</p>
<p>Lo que intento decir es la conocida expresión <strong>correlación no implica causalidad</strong>. Una razón por la que esto no es necesariamente cierto es que podemos estar omitiendo la variable <span class="math inline">\(z\)</span> de nuestro análisis. Cuando esto sucede, llamamos a <span class="math inline">\(z\)</span> <a href="https://en.wikipedia.org/wiki/Confounding">variable de confusión</a> o factor de confusión. En muchos escenarios reales <span class="math inline">\(z\)</span> es fácil de perder de vista. Tal vez no la medimos o no estaba presente en el conjunto de datos que nos enviaron, o ni siquiera pensamos que <span class="math inline">\(z\)</span> podría estar relacionado con nuestro problema. No tomar en cuenta las variables de confusión en un análisis podría llevarnos a establecer correlaciones falsas. Esto siempre es un problema cuando tratamos de explicar algo y también puede ser problemático cuando tratamos de predecir algo sin preocuparnos por comprender el mecanismo subyacente. Comprender el mecanismo nos ayuda a traducir lo que hemos aprendido a situaciones nuevas; las predicciones ciegas no siempre tienen buena transferibilidad. Por ejemplo, la cantidad de zapatillas producidas en Argentina podría utilizarse como un indicador simple para estimar la fortaleza de su economía, pero podría ser un pésimo predictor para otros países con una matriz de producción o un contexto cultural diferente.</p>
<p>A continuación vamos a usar datos sintéticos para explorar un poco el concepto de variable de confusión. El siguiente código simula una variable de confusión como <span class="math inline">\(x_1\)</span>. Esta variable tiene influencia tanto en <span class="math inline">\(x_2\)</span> como en <span class="math inline">\(y\)</span>:</p>
<div class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb39-2"><a href="#cb39-2"></a>N <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb39-3"><a href="#cb39-3"></a>x_1 <span class="op">=</span> np.random.normal(size<span class="op">=</span>N)</span>
<span id="cb39-4"><a href="#cb39-4"></a>x_2 <span class="op">=</span> x_1 <span class="op">+</span> np.random.normal(size<span class="op">=</span>N, scale<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb39-5"><a href="#cb39-5"></a><span class="co">#x_2 = x_1 + np.random.normal(size=N, scale=0.01)  </span></span>
<span id="cb39-6"><a href="#cb39-6"></a>y <span class="op">=</span> x_1 <span class="op">+</span> np.random.normal(size<span class="op">=</span>N)</span>
<span id="cb39-7"><a href="#cb39-7"></a>X <span class="op">=</span> np.vstack((x_1, x_2)).T</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Debido a como generamos los datos estos ya están centrados como se puede ver en la siguiente figura:</p>
<div class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1"></a>scatter_plot(X, y)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="05_Regresión_lineal_files/figure-html/cell-30-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Ahora vamos a construir tres modelos relacionados, el primero <code>m_x1x2</code>, es un modelo de regresión lineal con dos variables independientes <span class="math inline">\(x_1\)</span> y <span class="math inline">\(x_2\)</span> (apilados en la variable <span class="math inline">\(X\)</span>). El segundo modelo, <code>m_x1</code>, es una regresión lineal simple para y el tercero, <code>m_x2</code>, una regresión de línea simple para <span class="math inline">\(x_2\)</span>:</p>
<div class="cell" data-execution_count="30">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> m_x1x2:</span>
<span id="cb41-2"><a href="#cb41-2"></a>    α <span class="op">=</span> pm.Normal(<span class="st">'α'</span>, mu<span class="op">=</span><span class="dv">0</span>, sigma<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb41-3"><a href="#cb41-3"></a>    β<span class="dv">1</span> <span class="op">=</span> pm.Normal(<span class="st">'β1'</span>, mu<span class="op">=</span><span class="dv">0</span>, sigma<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb41-4"><a href="#cb41-4"></a>    β<span class="dv">2</span> <span class="op">=</span> pm.Normal(<span class="st">'β2'</span>, mu<span class="op">=</span><span class="dv">0</span>, sigma<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb41-5"><a href="#cb41-5"></a>    ϵ <span class="op">=</span> pm.HalfCauchy(<span class="st">'ϵ'</span>, <span class="dv">5</span>)</span>
<span id="cb41-6"><a href="#cb41-6"></a></span>
<span id="cb41-7"><a href="#cb41-7"></a>    μ <span class="op">=</span> α <span class="op">+</span> β<span class="dv">1</span> <span class="op">*</span> X[:,<span class="dv">0</span>] <span class="op">+</span> β<span class="dv">2</span> <span class="op">*</span> X[:,<span class="dv">1</span>] </span>
<span id="cb41-8"><a href="#cb41-8"></a>    </span>
<span id="cb41-9"><a href="#cb41-9"></a>    y_pred <span class="op">=</span> pm.Normal(<span class="st">'y_pred'</span>, mu<span class="op">=</span>μ, sigma<span class="op">=</span>ϵ, observed<span class="op">=</span>y)</span>
<span id="cb41-10"><a href="#cb41-10"></a> </span>
<span id="cb41-11"><a href="#cb41-11"></a>    idata_x1x2 <span class="op">=</span> pm.sample(<span class="dv">2000</span>)</span>
<span id="cb41-12"><a href="#cb41-12"></a>    </span>
<span id="cb41-13"><a href="#cb41-13"></a>    </span>
<span id="cb41-14"><a href="#cb41-14"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> m_x1:</span>
<span id="cb41-15"><a href="#cb41-15"></a>    α <span class="op">=</span> pm.Normal(<span class="st">'α'</span>, mu<span class="op">=</span><span class="dv">0</span>, sigma<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb41-16"><a href="#cb41-16"></a>    β<span class="dv">1</span> <span class="op">=</span> pm.Normal(<span class="st">'β1'</span>, mu<span class="op">=</span><span class="dv">0</span>, sigma<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb41-17"><a href="#cb41-17"></a>    ϵ <span class="op">=</span> pm.HalfCauchy(<span class="st">'ϵ'</span>, <span class="dv">5</span>)</span>
<span id="cb41-18"><a href="#cb41-18"></a></span>
<span id="cb41-19"><a href="#cb41-19"></a>    μ <span class="op">=</span> α <span class="op">+</span> β<span class="dv">1</span> <span class="op">*</span> X[:,<span class="dv">0</span>]</span>
<span id="cb41-20"><a href="#cb41-20"></a>    </span>
<span id="cb41-21"><a href="#cb41-21"></a>    y_pred <span class="op">=</span> pm.Normal(<span class="st">'y_pred'</span>, mu<span class="op">=</span>μ, sigma<span class="op">=</span>ϵ, observed<span class="op">=</span>y)</span>
<span id="cb41-22"><a href="#cb41-22"></a> </span>
<span id="cb41-23"><a href="#cb41-23"></a>    idata_x1 <span class="op">=</span> pm.sample(<span class="dv">2000</span>)</span>
<span id="cb41-24"><a href="#cb41-24"></a>    </span>
<span id="cb41-25"><a href="#cb41-25"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> m_x2:</span>
<span id="cb41-26"><a href="#cb41-26"></a>    α <span class="op">=</span> pm.Normal(<span class="st">'α'</span>, mu<span class="op">=</span><span class="dv">0</span>, sigma<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb41-27"><a href="#cb41-27"></a>    β<span class="dv">2</span> <span class="op">=</span> pm.Normal(<span class="st">'β2'</span>, mu<span class="op">=</span><span class="dv">0</span>, sigma<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb41-28"><a href="#cb41-28"></a>    ϵ <span class="op">=</span> pm.HalfCauchy(<span class="st">'ϵ'</span>, <span class="dv">5</span>)</span>
<span id="cb41-29"><a href="#cb41-29"></a></span>
<span id="cb41-30"><a href="#cb41-30"></a>    μ <span class="op">=</span> α <span class="op">+</span> β<span class="dv">2</span> <span class="op">*</span> X[:,<span class="dv">1</span>]</span>
<span id="cb41-31"><a href="#cb41-31"></a>    </span>
<span id="cb41-32"><a href="#cb41-32"></a>    y_pred <span class="op">=</span> pm.Normal(<span class="st">'y_pred'</span>, mu<span class="op">=</span>μ, sigma<span class="op">=</span>ϵ, observed<span class="op">=</span>y)</span>
<span id="cb41-33"><a href="#cb41-33"></a> </span>
<span id="cb41-34"><a href="#cb41-34"></a>    idata_x2 <span class="op">=</span> pm.sample(<span class="dv">2000</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (4 chains in 4 jobs)
NUTS: [α, β1, β2, ϵ]</code></pre>
</div>
<div class="cell-output cell-output-display">

<style>
    /* Turns off some styling */
    progress {
        /* gets rid of default border in Firefox and Opera. */
        border: none;
        /* Needs to be in here for Safari polyfill so background images work as expected. */
        background-size: auto;
    }
    progress:not([value]), progress:not([value])::-webkit-progress-bar {
        background: repeating-linear-gradient(45deg, #7e7e7e, #7e7e7e 10px, #5c5c5c 10px, #5c5c5c 20px);
    }
    .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
        background: #F44336;
    }
</style>
</div>
<div class="cell-output cell-output-display">

    <div>
      <progress value="12000" class="" max="12000" style="width:300px; height:20px; vertical-align: middle;"></progress>
      100.00% [12000/12000 00:02&lt;00:00 Sampling 4 chains, 0 divergences]
    </div>
    
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Sampling 4 chains for 1_000 tune and 2_000 draw iterations (4_000 + 8_000 draws total) took 3 seconds.
Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (4 chains in 4 jobs)
NUTS: [α, β1, ϵ]</code></pre>
</div>
<div class="cell-output cell-output-display">

<style>
    /* Turns off some styling */
    progress {
        /* gets rid of default border in Firefox and Opera. */
        border: none;
        /* Needs to be in here for Safari polyfill so background images work as expected. */
        background-size: auto;
    }
    progress:not([value]), progress:not([value])::-webkit-progress-bar {
        background: repeating-linear-gradient(45deg, #7e7e7e, #7e7e7e 10px, #5c5c5c 10px, #5c5c5c 20px);
    }
    .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
        background: #F44336;
    }
</style>
</div>
<div class="cell-output cell-output-display">

    <div>
      <progress value="12000" class="" max="12000" style="width:300px; height:20px; vertical-align: middle;"></progress>
      100.00% [12000/12000 00:02&lt;00:00 Sampling 4 chains, 0 divergences]
    </div>
    
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Sampling 4 chains for 1_000 tune and 2_000 draw iterations (4_000 + 8_000 draws total) took 2 seconds.
Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (4 chains in 4 jobs)
NUTS: [α, β2, ϵ]</code></pre>
</div>
<div class="cell-output cell-output-display">

<style>
    /* Turns off some styling */
    progress {
        /* gets rid of default border in Firefox and Opera. */
        border: none;
        /* Needs to be in here for Safari polyfill so background images work as expected. */
        background-size: auto;
    }
    progress:not([value]), progress:not([value])::-webkit-progress-bar {
        background: repeating-linear-gradient(45deg, #7e7e7e, #7e7e7e 10px, #5c5c5c 10px, #5c5c5c 20px);
    }
    .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
        background: #F44336;
    }
</style>
</div>
<div class="cell-output cell-output-display">

    <div>
      <progress value="12000" class="" max="12000" style="width:300px; height:20px; vertical-align: middle;"></progress>
      100.00% [12000/12000 00:02&lt;00:00 Sampling 4 chains, 0 divergences]
    </div>
    
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Sampling 4 chains for 1_000 tune and 2_000 draw iterations (4_000 + 8_000 draws total) took 2 seconds.</code></pre>
</div>
</div>
<p>A continuación usamos un forestplot a fin de comparar los valores de <span class="math inline">\(\beta\)</span> para estos 3 modelos.</p>
<div class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1"></a>ax <span class="op">=</span> az.plot_forest([idata_x1x2, idata_x1, idata_x2], model_names<span class="op">=</span>[<span class="st">'m_x1x2'</span>, <span class="st">'m_x1'</span>, <span class="st">'m_x2'</span>], var_names<span class="op">=</span>[<span class="st">'β1'</span>, <span class="st">'β2'</span>],</span>
<span id="cb46-2"><a href="#cb46-2"></a>                    r_hat<span class="op">=</span><span class="va">False</span>, ess<span class="op">=</span><span class="va">False</span>, combined<span class="op">=</span><span class="va">True</span>, colors<span class="op">=</span><span class="st">'cycle'</span>,</span>
<span id="cb46-3"><a href="#cb46-3"></a>                    kind<span class="op">=</span><span class="st">"ridgeplot"</span>,</span>
<span id="cb46-4"><a href="#cb46-4"></a>                    figsize<span class="op">=</span>(<span class="dv">9</span>, <span class="dv">4</span>))<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="05_Regresión_lineal_files/figure-html/cell-32-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Como podemos ver <span class="math inline">\(\beta_2\)</span> para el modelo <code>m_x1x2</code> es alrededor de cero, lo que indica una contribución casi nula de la variable <span class="math inline">\(x_2\)</span> para explicar <span class="math inline">\(y\)</span>. Esto es interesante porque ya sabemos que la variable realmente importante es <span class="math inline">\(x_1\)</span> (como se puede verificar en la generación de datos sintéticos). También hay que notar, y esto es realmente importante, <span class="math inline">\(\beta_2\)</span> para el modelo <code>m_x2</code> es alrededor de 0.55, es decir es más grande que para el modelo <code>m_x1x2</code>. En otras palabras el poder de <span class="math inline">\(x_2\)</span> para predecir <span class="math inline">\(y\)</span> se reduce cuando tenemos en cuenta <span class="math inline">\(x_1\)</span>, ya que la información en <span class="math inline">\(x_1\)</span> es redundante dado <span class="math inline">\(x_2\)</span>.</p>
</section>
<section id="multicolinearidad-o-cuando-la-correlación-es-demasiado-alta" class="level2" data-number="7.7">
<h2 data-number="7.7" class="anchored" data-anchor-id="multicolinearidad-o-cuando-la-correlación-es-demasiado-alta"><span class="header-section-number">7.7</span> Multicolinearidad o cuando la correlación es demasiado alta</h2>
<p>Llevemos el ejemplo anterior a un extremo y veamos qué sucede cuando dos variables están altamente correlacionadas. Para estudiar este problema y sus consecuencias para la inferencia, utilizaremos los mismos datos y modelos sintéticos que antes, pero ahora aumentaremos el grado de correlación entre <span class="math inline">\(x_1\)</span> y <span class="math inline">\(x_2\)</span> al reducir la cantidad de <em>ruido Gaussiano</em> que agregamos a <span class="math inline">\(x_1\)</span> para obtener <span class="math inline">\(x_2\)</span>.</p>
<div class="cell" data-execution_count="32">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1"></a><span class="co"># Este es el mismo código de una celdas antes pero con una valor más bajo de `scale`</span></span>
<span id="cb47-2"><a href="#cb47-2"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb47-3"><a href="#cb47-3"></a>N <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb47-4"><a href="#cb47-4"></a>x_1 <span class="op">=</span> np.random.normal(size<span class="op">=</span>N)</span>
<span id="cb47-5"><a href="#cb47-5"></a>x_2 <span class="op">=</span> x_1 <span class="op">+</span> np.random.normal(size<span class="op">=</span>N, scale<span class="op">=</span><span class="fl">0.01</span>)  </span>
<span id="cb47-6"><a href="#cb47-6"></a>y <span class="op">=</span> x_1 <span class="op">+</span> np.random.normal(size<span class="op">=</span>N)</span>
<span id="cb47-7"><a href="#cb47-7"></a>X <span class="op">=</span> np.vstack((x_1, x_2)).T</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El cambio en la generación de datos, de la celda anterior, prácticamente equivale a sumar 0 a <span class="math inline">\(x_1\)</span>, por lo tanto ambas variables son iguales para todo propósito práctico. A continuación, pueden intentar variar los valores de la desviación estándar y usar valores menos extremos, pero por ahora queremos que el efecto sea bien claro. En el siguiente gráfico se puede ver que ahora el diagrama de dispersión para <span class="math inline">\(x_1\)</span> y <span class="math inline">\(x_2\)</span> es prácticamente una línea recta con una pendiente alrededor de 1:</p>
<div class="cell" data-execution_count="33">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1"></a>scatter_plot(X, y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="05_Regresión_lineal_files/figure-html/cell-34-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Ejecutamos una regresión lineal múltiple:</p>
<div class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> model_red :</span>
<span id="cb49-2"><a href="#cb49-2"></a>    α <span class="op">=</span> pm.Normal(<span class="st">'α'</span>, mu<span class="op">=</span><span class="dv">0</span>, sigma<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb49-3"><a href="#cb49-3"></a>    β <span class="op">=</span> pm.Normal(<span class="st">'β'</span>, mu<span class="op">=</span><span class="dv">0</span>, sigma<span class="op">=</span><span class="dv">10</span>, shape<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb49-4"><a href="#cb49-4"></a>    ϵ <span class="op">=</span> pm.HalfCauchy(<span class="st">'ϵ'</span>, <span class="dv">5</span>)</span>
<span id="cb49-5"><a href="#cb49-5"></a></span>
<span id="cb49-6"><a href="#cb49-6"></a>    μ <span class="op">=</span> α <span class="op">+</span> pm.math.dot(X, β)</span>
<span id="cb49-7"><a href="#cb49-7"></a>    </span>
<span id="cb49-8"><a href="#cb49-8"></a>    y_pred <span class="op">=</span> pm.Normal(<span class="st">'y_pred'</span>, mu<span class="op">=</span>μ, sigma<span class="op">=</span>ϵ, observed<span class="op">=</span>y)</span>
<span id="cb49-9"><a href="#cb49-9"></a> </span>
<span id="cb49-10"><a href="#cb49-10"></a>    idata_red <span class="op">=</span> pm.sample(<span class="dv">2000</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (4 chains in 4 jobs)
NUTS: [α, β, ϵ]</code></pre>
</div>
<div class="cell-output cell-output-display">

<style>
    /* Turns off some styling */
    progress {
        /* gets rid of default border in Firefox and Opera. */
        border: none;
        /* Needs to be in here for Safari polyfill so background images work as expected. */
        background-size: auto;
    }
    progress:not([value]), progress:not([value])::-webkit-progress-bar {
        background: repeating-linear-gradient(45deg, #7e7e7e, #7e7e7e 10px, #5c5c5c 10px, #5c5c5c 20px);
    }
    .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
        background: #F44336;
    }
</style>
</div>
<div class="cell-output cell-output-display">

    <div>
      <progress value="12000" class="" max="12000" style="width:300px; height:20px; vertical-align: middle;"></progress>
      100.00% [12000/12000 01:03&lt;00:00 Sampling 4 chains, 0 divergences]
    </div>
    
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Sampling 4 chains for 1_000 tune and 2_000 draw iterations (4_000 + 8_000 draws total) took 63 seconds.</code></pre>
</div>
</div>
<p>Y verificamos los resultados de los parámetros con un forestplot:</p>
<div class="cell" data-execution_count="35">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1"></a>az.plot_forest(idata_red, var_names<span class="op">=</span>[<span class="st">'β'</span>], r_hat<span class="op">=</span><span class="dv">0</span>, ess<span class="op">=</span><span class="dv">0</span>, combined<span class="op">=</span><span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">2</span>))<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="05_Regresión_lineal_files/figure-html/cell-36-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Los valores de los HDI para <span class="math inline">\(\beta\)</span> son sospechosamente amplios, podemos obtener una idea de lo que está sucediendo con un diagrama de dispersión de los coeficientes <span class="math inline">\(\beta\)</span></p>
<div class="cell" data-execution_count="36">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1"></a>az.plot_pair(idata_red, var_names<span class="op">=</span>[<span class="st">'β'</span>], scatter_kwargs<span class="op">=</span>{<span class="st">'alpha'</span>:<span class="fl">0.05</span>})<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="05_Regresión_lineal_files/figure-html/cell-37-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>La distribución de los coeficientes <span class="math inline">\(\beta\)</span> es una diagonal realmente estrecha. Cuando un coeficiente <span class="math inline">\(\beta\)</span> sube, el otro debe bajar. Ambos están efectivamente correlacionados. Esto es solo una consecuencia del modelo y los datos. Según nuestro modelo, la media <span class="math inline">\(\mu\)</span> es:</p>
<p><span class="math display">\[ \mu = \alpha + \beta_1 x_1 + \beta_2 x_2 \tag{3.19} \]</span></p>
<p>Si suponemos que <span class="math inline">\(x_1\)</span> y <span class="math inline">\(x_2\)</span> no son prácticamente equivalentes, sino matemáticamente idénticos, podemos volver a escribir el modelo como:</p>
<p><span class="math display">\[ \mu = \alpha + (\beta_1 + \beta_2) x \tag{3.20} \]</span></p>
<p>Resulta que es la suma <span class="math inline">\(\beta_1 + \beta_2\)</span> y no sus valores separados, lo que afecta <span class="math inline">\(\mu\)</span>. Podemos hacer que <span class="math inline">\(\beta_1\)</span> sea más pequeño y más pequeño siempre que hagamos que <span class="math inline">\(\beta_2\)</span> sea más y más grande. Los resultados nos están diciendo que como prácticamente NO tenemos dos variables <span class="math inline">\(x\)</span>, prácticamente NO tenemos dos parámetros <span class="math inline">\(\beta\)</span>. Decimos entonces que el modelo está <strong>indeterminado</strong> (o de forma equivalente, los datos no pueden restringir los parámetros en el modelo). En nuestro ejemplo, hay dos razones por las cuales <span class="math inline">\(\beta\)</span> no se mueve libremente en el intervalo <span class="math inline">\((-\infty, \infty)\)</span>. Primero, ambas variables son casi las mismas, pero no son exactamente iguales, en segundo lugar, y lo más importante, los <em>a prioris</em> actuan como restricciones de los valores plausibles que <span class="math inline">\(\beta\)</span> puede tomar.</p>
<p>Hay un par de cosas que notar de este ejemplo. En primer lugar, el <em>a posteriori</em> es tan solo la consecuencia lógica de los datos y el modelo, por lo tanto no hay nada <em>de malo</em> en obtener distribuciones tan amplias para <span class="math inline">\(\beta\)</span>, <em>C’est la vie</em>. En segundo lugar, podemos confiar en este modelo para hacer predicciones ya que los valores predichos por el modelo están de acuerdo con los datos, es decir el modelo captura los datos muy bien. En tercer lugar, este puede no ser un modelo muy bueno para comprender nuestro problema. Puede ser más inteligente simplemente eliminar una de las variables del modelo. Terminaremos teniendo un modelo que predice los datos igual que antes, pero con una interpretación más simple.</p>
<p>En cualquier conjunto de datos real, van a existir variables (parcialmente) correlacionadas. Esto sucede por al menos dos razones: la existencia de correlaciones espurias y quizá lo más relevante; al estudiar un problema tendemos a recolectar información que consideramos relevante pero que puede ser parcialmente redundante. Por ejemplo, la cantidad de radiación solar, la temperatura y las precipitaciones son factores que influyen para predecir el rinde de un cultivo, y son variables que tienen a estar correlacionadas por ejemplo si el verano es la temporada de mayores lluvias.</p>
<p>¿Qué tan fuerte deben correlacionarse dos o más variables para convertirse en un problema? Bueno se suele considerar que a partir de 0.9845. No, mentira! Desafortunadamente, la estadística es una disciplina con muy pocos números mágicos. Siempre es posible hacer una matriz de correlación antes de ejecutar cualquier modelo y verificar las variables con una alta correlación de, digamos por encima de 0.9 o más. Sin embargo, el problema con este enfoque es que lo que realmente importa no son las correlaciones por pares que podemos observar en una matriz de correlación, sino la correlación de las variables dentro de un modelo, y como ya vimos, las variables se comportan de forma diferente cuando están aisladas que cuando se relacionan dentro de un modelo. Dos o más variables pueden aumentar o disminuir su correlación cuando se colocan en el contexto de otras variables en un modelo de regresión múltiple. Como siempre, una inspección cuidadosa de la distribución <em>a posteriori</em> junto con una aproximación iterativa y crítica del modelado, son muy recomendables y pueden ayudarnos a detectar problemas y comprender los datos y los modelos.</p>
<p>Solo como una guía rápida (a tomar con pinzas). ¿Qué deberíamos hacer si encontramos variables altamente correlacionadas?</p>
<ul>
<li>Si la correlación es realmente alta, podemos eliminar una de las variables del análisis; dado que ambas variables tienen información similar, cual eliminamos suele ser a menudo irrelevante. Podemos eliminar variables basadas en nuestra conveniencia, por ejemplo eliminar variables menos conocidas o más difíciles de interpretar o las más costosas de medir.</li>
<li>Otra posibilidad es crear una nueva variable promediando las variables redundantes. Una versión más sofisticada es usar un algoritmo de reducción de variables como un análisis de componentes principales (PCA). El problema con PCA es que las variables resultantes son combinaciones lineales de las originales que ofuscan, en general, la interpretabilidad de los resultados.</li>
<li>Otra solución es utilizar <em>a prioris</em> más fuertes para restringir los valores plausibles que puede adoptar el coeficiente, en este contexto los <em>a prioris</em> se usan como regularizadores de la inferencia (algo que discutiremos más adelante).</li>
</ul>
</section>
<section id="variables-de-efecto-de-enmascaramiento" class="level2" data-number="7.8">
<h2 data-number="7.8" class="anchored" data-anchor-id="variables-de-efecto-de-enmascaramiento"><span class="header-section-number">7.8</span> Variables de efecto de enmascaramiento</h2>
<p>Otro ejemplo de cómo las variables contribuyen a un resultado es el caso de las variables que enmascaran. Vamos a crear dos variables independientes (<span class="math inline">\(x_1\)</span> y <span class="math inline">\(x_2\)</span>), las cuales están positivamente correlacionadas entre sí y están correlacionadas con <span class="math inline">\(y\)</span>, pero en direcciones opuestas <span class="math inline">\(x_1\)</span> está correlacionada positivamente y <span class="math inline">\(x_2\)</span> correlacionada negativamente.</p>
<div class="cell" data-execution_count="37">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb54-2"><a href="#cb54-2"></a>N <span class="op">=</span> <span class="dv">126</span></span>
<span id="cb54-3"><a href="#cb54-3"></a>r <span class="op">=</span> <span class="fl">0.8</span></span>
<span id="cb54-4"><a href="#cb54-4"></a>x_1 <span class="op">=</span> np.random.normal(size<span class="op">=</span>N)</span>
<span id="cb54-5"><a href="#cb54-5"></a>x_2 <span class="op">=</span> np.random.normal(x_1, scale<span class="op">=</span>(<span class="dv">1</span> <span class="op">-</span> r <span class="op">**</span> <span class="dv">2</span>) <span class="op">**</span> <span class="fl">0.5</span>)</span>
<span id="cb54-6"><a href="#cb54-6"></a>y <span class="op">=</span> np.random.normal(x_1 <span class="op">-</span> x_2)</span>
<span id="cb54-7"><a href="#cb54-7"></a>X <span class="op">=</span> np.vstack((x_1, x_2)).T</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="38">
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1"></a>scatter_plot(X, y)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="05_Regresión_lineal_files/figure-html/cell-39-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Como hicimos antes, vamos a construir 3 modelos relacionados, el primero m_x1x2, es un modelo de regresión lineal con dos variables independientes <span class="math inline">\(x_1\)</span> y <span class="math inline">\(x_2\)</span> (<em>apilados</em> en la variable X). El segundo modelo, m_x1, es una regresión lineal simple para <span class="math inline">\(x_1\)</span> y el tercero, m_x2, una regresión lineal simple para <span class="math inline">\(x_2\)</span>.</p>
<div class="cell" data-execution_count="39">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> m_x1x2:</span>
<span id="cb56-2"><a href="#cb56-2"></a>    α <span class="op">=</span> pm.Normal(<span class="st">'α'</span>, mu<span class="op">=</span><span class="dv">0</span>, sigma<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb56-3"><a href="#cb56-3"></a>    β<span class="dv">1</span> <span class="op">=</span> pm.Normal(<span class="st">'β1'</span>, mu<span class="op">=</span><span class="dv">0</span>, sigma<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb56-4"><a href="#cb56-4"></a>    β<span class="dv">2</span> <span class="op">=</span> pm.Normal(<span class="st">'β2'</span>, mu<span class="op">=</span><span class="dv">0</span>, sigma<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb56-5"><a href="#cb56-5"></a>    ϵ <span class="op">=</span> pm.HalfCauchy(<span class="st">'ϵ'</span>, <span class="dv">5</span>)</span>
<span id="cb56-6"><a href="#cb56-6"></a></span>
<span id="cb56-7"><a href="#cb56-7"></a>    μ <span class="op">=</span> α <span class="op">+</span> β<span class="dv">1</span> <span class="op">*</span> X[:,<span class="dv">0</span>] <span class="op">+</span> β<span class="dv">2</span> <span class="op">*</span> X[:,<span class="dv">1</span>] </span>
<span id="cb56-8"><a href="#cb56-8"></a>    </span>
<span id="cb56-9"><a href="#cb56-9"></a>    y_pred <span class="op">=</span> pm.Normal(<span class="st">'y_pred'</span>, mu<span class="op">=</span>μ, sigma<span class="op">=</span>ϵ, observed<span class="op">=</span>y)</span>
<span id="cb56-10"><a href="#cb56-10"></a> </span>
<span id="cb56-11"><a href="#cb56-11"></a>    trace_x1x2 <span class="op">=</span> pm.sample(<span class="dv">1000</span>)</span>
<span id="cb56-12"><a href="#cb56-12"></a>    </span>
<span id="cb56-13"><a href="#cb56-13"></a>    </span>
<span id="cb56-14"><a href="#cb56-14"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> m_x1:</span>
<span id="cb56-15"><a href="#cb56-15"></a>    α <span class="op">=</span> pm.Normal(<span class="st">'α'</span>, mu<span class="op">=</span><span class="dv">0</span>, sigma<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb56-16"><a href="#cb56-16"></a>    β<span class="dv">1</span> <span class="op">=</span> pm.Normal(<span class="st">'β1'</span>, mu<span class="op">=</span><span class="dv">0</span>, sigma<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb56-17"><a href="#cb56-17"></a>    ϵ <span class="op">=</span> pm.HalfCauchy(<span class="st">'ϵ'</span>, <span class="dv">5</span>)</span>
<span id="cb56-18"><a href="#cb56-18"></a></span>
<span id="cb56-19"><a href="#cb56-19"></a>    μ <span class="op">=</span> α <span class="op">+</span> β<span class="dv">1</span> <span class="op">*</span> X[:,<span class="dv">0</span>]</span>
<span id="cb56-20"><a href="#cb56-20"></a>    </span>
<span id="cb56-21"><a href="#cb56-21"></a>    y_pred <span class="op">=</span> pm.Normal(<span class="st">'y_pred'</span>, mu<span class="op">=</span>μ, sigma<span class="op">=</span>ϵ, observed<span class="op">=</span>y)</span>
<span id="cb56-22"><a href="#cb56-22"></a> </span>
<span id="cb56-23"><a href="#cb56-23"></a>    trace_x1 <span class="op">=</span> pm.sample(<span class="dv">1000</span>)</span>
<span id="cb56-24"><a href="#cb56-24"></a>    </span>
<span id="cb56-25"><a href="#cb56-25"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> m_x2:</span>
<span id="cb56-26"><a href="#cb56-26"></a>    α <span class="op">=</span> pm.Normal(<span class="st">'α'</span>, mu<span class="op">=</span><span class="dv">0</span>, sigma<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb56-27"><a href="#cb56-27"></a>    β<span class="dv">2</span> <span class="op">=</span> pm.Normal(<span class="st">'β2'</span>, mu<span class="op">=</span><span class="dv">0</span>, sigma<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb56-28"><a href="#cb56-28"></a>    ϵ <span class="op">=</span> pm.HalfCauchy(<span class="st">'ϵ'</span>, <span class="dv">5</span>)</span>
<span id="cb56-29"><a href="#cb56-29"></a></span>
<span id="cb56-30"><a href="#cb56-30"></a>    μ <span class="op">=</span> α <span class="op">+</span> β<span class="dv">2</span> <span class="op">*</span> X[:,<span class="dv">1</span>]</span>
<span id="cb56-31"><a href="#cb56-31"></a>    </span>
<span id="cb56-32"><a href="#cb56-32"></a>    y_pred <span class="op">=</span> pm.Normal(<span class="st">'y_pred'</span>, mu<span class="op">=</span>μ, sigma<span class="op">=</span>ϵ, observed<span class="op">=</span>y)</span>
<span id="cb56-33"><a href="#cb56-33"></a> </span>
<span id="cb56-34"><a href="#cb56-34"></a>    trace_x2 <span class="op">=</span> pm.sample(<span class="dv">1000</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (4 chains in 4 jobs)
NUTS: [α, β1, β2, ϵ]</code></pre>
</div>
<div class="cell-output cell-output-display">

<style>
    /* Turns off some styling */
    progress {
        /* gets rid of default border in Firefox and Opera. */
        border: none;
        /* Needs to be in here for Safari polyfill so background images work as expected. */
        background-size: auto;
    }
    progress:not([value]), progress:not([value])::-webkit-progress-bar {
        background: repeating-linear-gradient(45deg, #7e7e7e, #7e7e7e 10px, #5c5c5c 10px, #5c5c5c 20px);
    }
    .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
        background: #F44336;
    }
</style>
</div>
<div class="cell-output cell-output-display">

    <div>
      <progress value="8000" class="" max="8000" style="width:300px; height:20px; vertical-align: middle;"></progress>
      100.00% [8000/8000 00:03&lt;00:00 Sampling 4 chains, 0 divergences]
    </div>
    
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Sampling 4 chains for 1_000 tune and 1_000 draw iterations (4_000 + 4_000 draws total) took 4 seconds.
Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (4 chains in 4 jobs)
NUTS: [α, β1, ϵ]</code></pre>
</div>
<div class="cell-output cell-output-display">

<style>
    /* Turns off some styling */
    progress {
        /* gets rid of default border in Firefox and Opera. */
        border: none;
        /* Needs to be in here for Safari polyfill so background images work as expected. */
        background-size: auto;
    }
    progress:not([value]), progress:not([value])::-webkit-progress-bar {
        background: repeating-linear-gradient(45deg, #7e7e7e, #7e7e7e 10px, #5c5c5c 10px, #5c5c5c 20px);
    }
    .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
        background: #F44336;
    }
</style>
</div>
<div class="cell-output cell-output-display">

    <div>
      <progress value="8000" class="" max="8000" style="width:300px; height:20px; vertical-align: middle;"></progress>
      100.00% [8000/8000 00:01&lt;00:00 Sampling 4 chains, 0 divergences]
    </div>
    
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Sampling 4 chains for 1_000 tune and 1_000 draw iterations (4_000 + 4_000 draws total) took 2 seconds.
Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (4 chains in 4 jobs)
NUTS: [α, β2, ϵ]</code></pre>
</div>
<div class="cell-output cell-output-display">

<style>
    /* Turns off some styling */
    progress {
        /* gets rid of default border in Firefox and Opera. */
        border: none;
        /* Needs to be in here for Safari polyfill so background images work as expected. */
        background-size: auto;
    }
    progress:not([value]), progress:not([value])::-webkit-progress-bar {
        background: repeating-linear-gradient(45deg, #7e7e7e, #7e7e7e 10px, #5c5c5c 10px, #5c5c5c 20px);
    }
    .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
        background: #F44336;
    }
</style>
</div>
<div class="cell-output cell-output-display">

    <div>
      <progress value="8000" class="" max="8000" style="width:300px; height:20px; vertical-align: middle;"></progress>
      100.00% [8000/8000 00:01&lt;00:00 Sampling 4 chains, 0 divergences]
    </div>
    
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Sampling 4 chains for 1_000 tune and 1_000 draw iterations (4_000 + 4_000 draws total) took 2 seconds.</code></pre>
</div>
</div>
<p>Echemos un vistazo a los parámetros <span class="math inline">\(\beta\)</span> usando un <code>forestplot</code> para compararlos en un solo diagrama.</p>
<div class="cell" data-execution_count="40">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1"></a>az.plot_forest([trace_x1x2, trace_x1, trace_x2], model_names<span class="op">=</span>[<span class="st">'m_x1x2'</span>, <span class="st">'m_x1'</span>, <span class="st">'m_x2'</span>],</span>
<span id="cb61-2"><a href="#cb61-2"></a>               var_names<span class="op">=</span>[<span class="st">'β1'</span>, <span class="st">'β2'</span>], r_hat<span class="op">=</span><span class="va">False</span>, ess<span class="op">=</span><span class="va">False</span>, combined<span class="op">=</span><span class="va">True</span>, </span>
<span id="cb61-3"><a href="#cb61-3"></a>               kind<span class="op">=</span><span class="st">"ridgeplot"</span>, colors<span class="op">=</span><span class="st">'cycle'</span>,</span>
<span id="cb61-4"><a href="#cb61-4"></a>               figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">4</span>))<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="05_Regresión_lineal_files/figure-html/cell-41-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>De acuerdo a la distribución <em>a posteriori</em>, los valores de <span class="math inline">\(\beta\)</span> para <code>m_x1x2</code> están cerca de 1 y -1 (como se esperaba, de acuerdo a la forma en que generamos los datos). Para el modelo de regresión lineal simple, es decir, cuando estudiamos cada variable por separado, podemos ver que los valores de <span class="math inline">\(\beta\)</span> son más cercanos a cero, lo que indica un efecto más débil.</p>
<p>Lo que sucede es que <span class="math inline">\(x_1\)</span> está correlacionado con <span class="math inline">\(x_2\)</span>, cuando <span class="math inline">\(x_1\)</span> aumenta <span class="math inline">\(x_2\)</span> también aumenta. Además <span class="math inline">\(y\)</span> aumenta, <span class="math inline">\(x_1\)</span> también aumenta, pero <span class="math inline">\(x_2\)</span> disminuye. Como resultado de este arreglo particular, obtenemos una cancelación parcial de los efectos a menos que incluyamos ambas variables en la misma regresión lineal. El modelo de regresión lineal puede desenredar estos efectos porque el modelo está aprendiendo, para cada punto de datos, cuál es la contribución de <span class="math inline">\(x_1\)</span> a <span class="math inline">\(y\)</span> dado un valor de <span class="math inline">\(x_2\)</span>, y al revés por <span class="math inline">\(x_2\)</span>.</p>
</section>
<section id="resumen" class="level2" data-number="7.9">
<h2 data-number="7.9" class="anchored" data-anchor-id="resumen"><span class="header-section-number">7.9</span> Resumen</h2>
<p>Una regresión lineal simple es un modelo que puede usarse para predecir y/o explicar una variable desde otra. Desde una perspectiva probabilista, un modelo de regresión lineal es una extensión del modelo Gaussiano donde la media no se estima directamente, sino que se calcula como una función lineal de una variable de predicción y algunos parámetros adicionales. Si bien la distribución gaussiana es la opción más común para la variable dependiente, somos libres de elegir otras distribuciones. Una alternativa especialmente útil cuando se trata de posibles valores atípicos, es la distribución t de Student. Otra forma útil de expandir un modelo de regresión lineal es haciendo una versión jerárquica de él. Esto es muy simple de lograr con PyMC y obtenemos los beneficios del <em>shrinkage</em>.</p>
</section>
</section>
<section id="ejercicios" class="level1" data-number="8">
<h1 data-number="8"><span class="header-section-number">8</span> Ejercicios</h1>
<ol type="1">
<li>En la siguiente definición de modelo probabilístico cual es el <em>likelihood</em>, cual es el <em>a priori</em> y cual el <em>a posteriori</em>.</li>
</ol>
<p><span class="math display">\[
y_i \sim Normal(\mu, \sigma) \\
\mu \sim Normal(0, 10) \\
\sigma \sim HalfNormal(25)
\]</span></p>
<ol start="2" type="1">
<li><p>En el modelo del punto 1 ¿cuántos parámetros hay en el posterior? o expresado de otra forma ¿cuántas dimensiones tiene el <em>a posteriori</em>?</p></li>
<li><p>Escriba el teorema de Bayes para el modelo del punto 1.</p></li>
<li><p>En el siguiente modelo ¿cuál es el modelo lineal? ¿cuál el likelihood y cuantos parámetros hay en la distribución a posteriori?</p></li>
</ol>
<p><span class="math display">\[
y \sim Normal(\mu, \epsilon) \\
\mu = \alpha + \beta x \\
\alpha \sim Normal(0, 10) \\
\beta \sim Normal(0, 1) \\
\epsilon \sim HalfNormal(25) \\
\]</span></p>
<ol start="5" type="1">
<li>Para el modelo del punto 1, asumiendo que tiene 57 datos provenientes de una gaussiana con media 4 y desviación estándar 0.5, obtenga usando PyMC:
<ul>
<li>La distribución a posteriori</li>
<li>La distribución a priori</li>
<li>La distribución predictiva a posteriori</li>
<li>La distribución predictiva a priori</li>
</ul></li>
<li>Ejecuta el modelo <code>model_g</code>:
<ul>
<li>Usando NUTS (sampler por defecto)</li>
<li>Usando Metropolis</li>
</ul></li>
</ol>
<p>Compare los resultados usando funciones de ArviZ como <code>plot_trace</code> y <code>plot_pairs</code>. Centre la variable <span class="math inline">\(x\)</span> y repita el ejercicio ¿Qué opina?</p>
<ol start="7" type="1">
<li><p>Usando el conjunto de datos <code>howell</code> (disponible junto con esta notebook) realice un modelo lineal del peso (<span class="math inline">\(x\)</span>) versus la altura (<span class="math inline">\(y\)</span>). Excluya a los menores de 18 años. Exponga los resultados.</p></li>
<li><p>Para 4 individuos se registraron los pesos (45.73, 65.8, 54.2, 32.59), pero no las alturas. Usando el modelo del punto anterior prediga la altura esperada para cada individuo junto con un intervalo de credibilidad del 50% y del 89%.</p></li>
<li><p>Repita el punto 7 pero para los menores de 18 años. Exponga los resultados.</p></li>
<li><p>Escriba en PyMC un modelo lineal para predecir la cantidad de papers que un estudiante de doctorado producirá en función de el tamaño del grupo donde trabaja el estudiante, la cantidad de fondos que recibe el grupo, el género del estudiante ¿Cómo cambia el modelo si se asume género binario o género categórico (más de dos opciones)?</p></li>
<li><p>Supongamos que el siguiente enunciado es cierto “las ciudades en Argentina con más policías tienen más delitos” ¿Quiere decir esto que la policía Argentina es corrupta?</p></li>
<li><p>Lea este <a href="https://twiecki.github.io/blog/2017/02/08/bayesian-hierchical-non-centered/">post</a> y replique los resultados usted mismo.</p></li>
</ol>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  let localAlternateSentinel = 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./04_Diagnóstico_MCMC.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Diagnóstico del muestreo</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./06_Generalizando_modelos_lineales.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Generalizando modelos lineales</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
      <div class="nav-footer-center"><a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Licencia de Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/80x15.png"></a><br>Este obra está bajo una <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">licencia de Creative Commons Reconocimiento 4.0 Internacional</a>.</div>
  </div>
</footer>



</body></html>