<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.335">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>programación_probabilística</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title"></h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation docked overflow-auto">
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        <div class="sidebar-tools-collapse">
    <a href="" title="" id="sidebar-tool-dropdown-0" class="sidebar-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi bi-github"></i></a>
    <ul class="dropdown-menu" aria-labelledby="sidebar-tool-dropdown-0">
        <li>
          <a class="dropdown-item sidebar-tools-collapse-item" href="https://github.com/Grupo-de-modelado-probabilista/Modelado_Bayesiano">
          Fuente
          </a>
        </li>
        <li>
          <a class="dropdown-item sidebar-tools-collapse-item" href="https://github.com/Grupo-de-modelado-probabilista/Modelado_Bayesiano/issues/new">
          Reportar errores
          </a>
        </li>
    </ul>
</div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">home</a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">Introducción al modelado, inferencia y análisis de modelos Bayesianos</a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">Capítulo 0</a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./00_Probabilidad.html" class="sidebar-item-text sidebar-link">Probabilidad</a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true">Capítulo 1</a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01_Inferencia_Bayesiana.html" class="sidebar-item-text sidebar-link">Inferencia Bayesiana</a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="true">Capítulo 2</a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="true">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02_Programación_probabilística.html" class="sidebar-item-text sidebar-link active">Programación probabilista</a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="true">Capítulo 3</a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="true">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03_Modelos_jerárquicos.html" class="sidebar-item-text sidebar-link">Modelado Jerárquico</a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" aria-expanded="true">Capítulo 4</a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" aria-expanded="true">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04_Diagnóstico_MCMC.html" class="sidebar-item-text sidebar-link">MCMC y diagnóstico del muestro</a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" aria-expanded="true">Capítulo 5</a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" aria-expanded="true">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-7" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05_Regresión_lineal.html" class="sidebar-item-text sidebar-link">Regresión Lineal</a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-8" aria-expanded="true">Capítulo 6</a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-8" aria-expanded="true">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-8" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06_Generalizando_modelos_lineales.html" class="sidebar-item-text sidebar-link">Generalizando modelos lineales</a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-9" aria-expanded="true">Capítulo 7</a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-9" aria-expanded="true">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-9" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07_Comparación_de_modelos.html" class="sidebar-item-text sidebar-link">Comparación de modelos</a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#programación-probabilista" id="toc-programación-probabilista" class="nav-link active" data-scroll-target="#programación-probabilista">Programación probabilista</a>
  <ul class="collapse">
  <li><a href="#objetivos-de-este-capítulo" id="toc-objetivos-de-este-capítulo" class="nav-link" data-scroll-target="#objetivos-de-este-capítulo">Objetivos de este capítulo</a></li>
  </ul></li>
  <li><a href="#programación-probabilística" id="toc-programación-probabilística" class="nav-link" data-scroll-target="#programación-probabilística">Programación probabilística</a>
  <ul class="collapse">
  <li><a href="#introducción-a-pymc" id="toc-introducción-a-pymc" class="nav-link" data-scroll-target="#introducción-a-pymc">Introducción a PyMC</a></li>
  <li><a href="#el-problema-de-la-moneda-ahora-usando-pymc-y-arviz" id="toc-el-problema-de-la-moneda-ahora-usando-pymc-y-arviz" class="nav-link" data-scroll-target="#el-problema-de-la-moneda-ahora-usando-pymc-y-arviz">El problema de la moneda, ahora usando PyMC y ArviZ</a>
  <ul class="collapse">
  <li><a href="#creación-del-modelo" id="toc-creación-del-modelo" class="nav-link" data-scroll-target="#creación-del-modelo">Creación del modelo</a></li>
  <li><a href="#inferencia" id="toc-inferencia" class="nav-link" data-scroll-target="#inferencia">Inferencia</a></li>
  </ul></li>
  <li><a href="#resumiendo-el-a-posteriori" id="toc-resumiendo-el-a-posteriori" class="nav-link" data-scroll-target="#resumiendo-el-a-posteriori">Resumiendo el <em>a posteriori</em></a></li>
  <li><a href="#decisiones-basadas-en-el-posterior" id="toc-decisiones-basadas-en-el-posterior" class="nav-link" data-scroll-target="#decisiones-basadas-en-el-posterior">Decisiones basadas en el posterior</a>
  <ul class="collapse">
  <li><a href="#funciones-de-perdida" id="toc-funciones-de-perdida" class="nav-link" data-scroll-target="#funciones-de-perdida">Funciones de perdida</a></li>
  </ul></li>
  <li><a href="#modelos-multiparamétricos" id="toc-modelos-multiparamétricos" class="nav-link" data-scroll-target="#modelos-multiparamétricos">Modelos Multiparamétricos</a>
  <ul class="collapse">
  <li><a href="#inferencias-lumínicas" id="toc-inferencias-lumínicas" class="nav-link" data-scroll-target="#inferencias-lumínicas">Inferencias lumínicas</a></li>
  <li><a href="#modelos-robustos" id="toc-modelos-robustos" class="nav-link" data-scroll-target="#modelos-robustos">Modelos robustos</a></li>
  <li><a href="#accidentes-mineros" id="toc-accidentes-mineros" class="nav-link" data-scroll-target="#accidentes-mineros">Accidentes mineros</a></li>
  </ul></li>
  <li><a href="#pruebas-predictivas-a-posteriori" id="toc-pruebas-predictivas-a-posteriori" class="nav-link" data-scroll-target="#pruebas-predictivas-a-posteriori">Pruebas predictivas a posteriori</a></li>
  <li><a href="#pruebas-predictivas-a-priori" id="toc-pruebas-predictivas-a-priori" class="nav-link" data-scroll-target="#pruebas-predictivas-a-priori">Pruebas predictivas <em>a priori</em></a></li>
  <li><a href="#comparando-grupos" id="toc-comparando-grupos" class="nav-link" data-scroll-target="#comparando-grupos">Comparando grupos</a>
  <ul class="collapse">
  <li><a href="#d-de-cohen" id="toc-d-de-cohen" class="nav-link" data-scroll-target="#d-de-cohen">d de Cohen</a></li>
  <li><a href="#probabilidad-de-superioridad" id="toc-probabilidad-de-superioridad" class="nav-link" data-scroll-target="#probabilidad-de-superioridad">Probabilidad de superioridad</a></li>
  </ul></li>
  <li><a href="#resumen" id="toc-resumen" class="nav-link" data-scroll-target="#resumen">Resumen</a></li>
  <li><a href="#para-seguir-leyendo" id="toc-para-seguir-leyendo" class="nav-link" data-scroll-target="#para-seguir-leyendo">Para seguir leyendo</a></li>
  <li><a href="#ejercicios" id="toc-ejercicios" class="nav-link" data-scroll-target="#ejercicios">Ejercicios</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">



<section id="programación-probabilista" class="level1">
<h1>Programación probabilista</h1>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> arviz <span class="im">as</span> az</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pymc <span class="im">as</span> pm</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> preliz <span class="im">as</span> pz</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.stats <span class="im">as</span> stats</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>az.style.use(<span class="st">'arviz-doc'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span>javascript</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>IPython.OutputArea.prototype._should_scroll <span class="op">=</span> function(lines) {</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> false<span class="op">;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<script type="application/javascript">
IPython.OutputArea.prototype._should_scroll = function(lines) {
    return false;
}

</script>
</div>
</div>
<section id="objetivos-de-este-capítulo" class="level2">
<h2 class="anchored" data-anchor-id="objetivos-de-este-capítulo">Objetivos de este capítulo</h2>
<ul>
<li>Construir modelos con PyMC</li>
<li>Analizar modelos con PyMC y ArviZ</li>
<li>Explorar formas alternativas de interpretar el <em>a posteriori</em></li>
<li>La importancia del tamaño del efecto vs la irrelavancia de la significancia.</li>
<li>Aprender sobre modelos jerárquicos
<ul>
<li>agrupamiento-parcial</li>
<li>efecto de <em>contracción</em></li>
</ul></li>
</ul>
</section>
</section>
<section id="programación-probabilística" class="level1">
<h1>Programación probabilística</h1>
<blockquote class="blockquote">
<p>Nuestros golems raramente tienen forma física, pero a menudo están hechos de arcilla y viven <em>in silicio</em> como código de computadora -Richard McElreath</p>
</blockquote>
<p>La estadística Bayesiana es conceptualmente muy simple, tenemos lo <em>conocido</em> y lo <em>desconocido</em>. El teorema de Bayes se utiliza para condicionar lo desconocido usando lo conocido, si tenemos suerte este proceso conducirá a una reducción de la incertidumbre sobre lo desconocido. Por lo general nos referimos a lo conocido como datos y los consideramos fijo mientras que lo desconocido toma la forma de parámetros de distribuciones de probabilidad. La simpleza conceptual para formular modelos Bayesianos contrasta con la dificultad matemático/computacional para resolverlos. Por muchos años esto fue un verdadero problema y retrasó la adopción de métodos Bayesianos.</p>
<p>A fin de poder resolver los modelos Bayesianos se recurre a métodos numéricos que pueden ser considerados como <em>motores universales de inferencia</em>. El hecho que tales motores sean posibles ha motivado el surgimiento de la programación probabilística, este tipo de lenguajes permiten una separación clara entre la creación de los modelos y el proceso de inferencia.</p>
<p>Un lenguaje de programación probabilístico es, en lineas generales, un lenguaje que le permite al usuario describir, en una pocas lineas de código (las necesarias para describir el modelo), un modelo probabilístico completo. Luego se procede a utilizar este modelo para realizar la inferencia de forma automática. Se espera que la programación probabilística tenga un gran impacto en estadística, <em>machine learning</em> y otras disciplinas al permitir que científicos construyan modelos complejos en menor tiempo y de forma menos propensa a errores.</p>
<p>Una buena analogía sobre el impacto que un lenguaje de programación puede tener en la ciencia es la introducción del lenguaje de programación Fortran hace más de 6 décadas. Fortran permitió a los científicos, por primera vez, abstraerse de muchos de los detalles computacionales y centrarse en la construcción de métodos numéricos, modelos y simulaciones de una manera más natural. De manera similar, se espera que los lenguajes de programación probabilísticos escondan del usuario detalles sobre cómo las probabilidades son manipuladas y cómo se lleva a cabo la inferencia, dejando que los usuarios se centren en la especificación del modelo y en el análisis e interpretación de los resultados.</p>
<section id="introducción-a-pymc" class="level2">
<h2 class="anchored" data-anchor-id="introducción-a-pymc">Introducción a PyMC</h2>
<p>PyMC es un paquete para programación probabilística bajo Python. PyMC es lo suficientemente madura para resolver muchos problemas estadísticos. PyMC permite crear modelos probabilísticos usando una sintaxis intuitiva y fácil de leer que es muy similar a la sintaxis usada para describir modelos probabilísticos.</p>
<p>La mayoría de las funciones de PyMC están escritas en Python. Mientras que las partes computacionalmente demandantes están escritas en NumPy y <a href="https://aesara.readthedocs.io/en/latest/">Aesara</a>. Aesara es una biblioteca de Python que permite definir, optimizar y evaluar expresiones matemáticas que involucran matrices multidimensionales de manera eficiente. Aesara es hija de Theano una librería de Python originalmente desarrollada para <em>deep learning</em> (que es a su vez la antesesora de TensorFlow, PyTorch, etc).</p>
</section>
<section id="el-problema-de-la-moneda-ahora-usando-pymc-y-arviz" class="level2">
<h2 class="anchored" data-anchor-id="el-problema-de-la-moneda-ahora-usando-pymc-y-arviz">El problema de la moneda, ahora usando PyMC y ArviZ</h2>
<p>A continuación revisitaremos el problema de la moneda visto en el capítulo anterior, usando esta vez PyMC para definir nuestro modelo y hacer inferencia. Luego usaremos ArviZ para analizar el <em>a posterori</em>.</p>
<p>A continuación generaremos datos sintéticos, en este caso asumiremos que conocemos el valor the <span class="math inline">\(\theta\)</span> y lo llamaremos <code>theta_real</code>, y luego intentaremos <em>averiguar</em> este valor <em>como si no</em> lo conocieramos. En un problema <em>real</em> <code>theta_real</code> sería desconocido y realizaríamos un proceso de inferencia precisamtente para averiguar su valor.</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">123</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>n_experimentos <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>theta_real <span class="op">=</span> <span class="fl">.35</span>  <span class="co"># en una situación real este valor es desconocido</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>datos <span class="op">=</span> pz.Binomial(n<span class="op">=</span><span class="dv">1</span>, p<span class="op">=</span>theta_real).rvs(size<span class="op">=</span>n_experimentos)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>datos</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<pre><code>array([1, 0, 0, 0])</code></pre>
</div>
</div>
<section id="creación-del-modelo" class="level3">
<h3 class="anchored" data-anchor-id="creación-del-modelo">Creación del modelo</h3>
<p>Ahora que tenemos nuestros datos es necesario especificar el modelo. Para ello usaremos una distribución beta (con parámetros <span class="math inline">\(\alpha=\beta=1\)</span>) como <em>a priori</em> y la distribución de Bernoulli como likelihood. Usando la notación usual en estadística tenemos:</p>
<p><span class="math display">\[\begin{align}
\theta &amp;\sim \operatorname{Beta}(\alpha=1, \beta=1)\\
Y &amp;\sim \operatorname{Bin}(n=1, p=\theta)
\end{align}\]</span></p>
<blockquote class="blockquote">
<p>Cada uno de los elementos del <em>array</em> <code>datos</code> es un experimento de Bernoulli, es decir un experimento donde solo es posible obtener dos valores (0 o 1) si en cambio tuviera el número total de “caras” obtenidas en varios experimentos de Bernoulli podríamos modelar el likelihood como una distribución Binomial.</p>
</blockquote>
<p>Esto modelo se traduce casi literalmente a PyMC, veamos:</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> nuestro_primer_modelo:</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    θ <span class="op">=</span> pm.Beta(<span class="st">'θ'</span>, alpha<span class="op">=</span><span class="dv">1</span>, beta<span class="op">=</span><span class="dv">1</span>)  <span class="co"># a priori</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> pm.Bernoulli(<span class="st">'y'</span>, p<span class="op">=</span>θ, observed<span class="op">=</span>datos)  <span class="co"># likelihood</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">#y = pm.Binomial('y',n=n_experimentos, p=θ, observed=sum(datos))</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>En la primer linea hemos creado un nuevo objeto llamado <em>nuestro_primer_modelo</em>. Este objeto contiene información sobre el modelo y las variables que lo conforman. PyMC usa el bloque <em>with</em> para indicar que todas las lineas que están dentro de él hacen referencia al mismo modelo (que en este caso se llama <em>nuestro_primer_modelo</em>).</p>
<p>La segunda linea de código, especifica el <em>a priori</em>, como pueden ver la sintaxis sigue de cerca a la notación matemática, la única diferencia es que el primer argumento es siempre una <em>cadena</em> que especifica el nombre de la variable aleatoria (el nombre es usado internamente por PyMC), este nombre siempre deberá coincidir con el nombre de la variable de Python a la que se le asigna. De no ser así el código correrá igual, pero puede conducir a errores y confusiones al analizar el modelo.</p>
<blockquote class="blockquote">
<p>Es importante recalcar que las variables de PyMC, como <span class="math inline">\(\theta\)</span>, no son números sino objetos que representan distribuciones. Es decir objetos a partir de los cuales es posible calcular probabilidades y generar números aleatorios.</p>
</blockquote>
<p>En la tercer linea de código se especifica el <em>likelihood</em>, que como verán es similar a la linea anterior con la diferencia que hemos agregado un argumento llamado <code>observed</code> al cual le asignamos nuestros datos. Esta es la forma de indicarle a PyMC cuales son los datos. Los datos pueden ser números, listas de Python, <em>arrays</em> de NumPy o <em>data_frames</em> de Pandas.</p>
</section>
<section id="inferencia" class="level3">
<h3 class="anchored" data-anchor-id="inferencia">Inferencia</h3>
<p>Nuestro modelo ya está completamente especificado, lo único que nos resta hacer es obtener el <em>a posteriori</em>. En el capítulo anterior vimos como hacerlo de forma analítica, ahora lo haremos con métodos numéricos.</p>
<p>En PyMC la inferencia se realiza escribiendo las siguientes lineas:</p>
<div class="cell" data-scrolled="true" data-execution_count="6">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> nuestro_primer_modelo:</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    idata <span class="op">=</span> pm.sample(<span class="dv">1000</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (4 chains in 4 jobs)
NUTS: [θ]</code></pre>
</div>
<div class="cell-output cell-output-display">

<style>
    /* Turns off some styling */
    progress {
        /* gets rid of default border in Firefox and Opera. */
        border: none;
        /* Needs to be in here for Safari polyfill so background images work as expected. */
        background-size: auto;
    }
    progress:not([value]), progress:not([value])::-webkit-progress-bar {
        background: repeating-linear-gradient(45deg, #7e7e7e, #7e7e7e 10px, #5c5c5c 10px, #5c5c5c 20px);
    }
    .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
        background: #F44336;
    }
</style>
</div>
<div class="cell-output cell-output-display">

    <div>
      <progress value="8000" class="" max="8000" style="width:300px; height:20px; vertical-align: middle;"></progress>
      100.00% [8000/8000 00:00&lt;00:00 Sampling 4 chains, 0 divergences]
    </div>
    
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Sampling 4 chains for 1_000 tune and 1_000 draw iterations (4_000 + 4_000 draws total) took 1 seconds.</code></pre>
</div>
</div>
<p>Primero llamamos al objeto que definimos como nuestro modelo (<em>nuestro_primer_modelo</em>), indicando de esta forma que es sobre ese objeto que queremos realizar la inferencia. En la segunda linea le indicamos a PyMC que deseamos 1000 muestras. Esta linea luce inocente, pero internamente PyMC está haciendo muchas cosas por nosotros. Algunas de las cuales son detalladas en el mensaje que se imprime en pantalla.</p>
<p>Veamos este mensaje:</p>
<ul>
<li>La primer linea indica que PyMC ha asignado el método de muestreo NUTS, el cual es un muy buen método para variables continuas.</li>
<li>La segunda linea nos da información sobre cómo se inicializaron los valores de NUTS. Un detalle que por ahora no nos preocupa.</li>
<li>La tercer linea indica que PyMC correrá cuatro cadenas en paralelo, es decir generará cuatro muestras independientes del <em>a posteriori</em>. Esta cantidad puede ser diferente en sus computadoras ya que es determinada automáticamente en función de los procesadores disponibles (que en mi caso, 4). <code>sample</code> tiene un argumento <code>chains</code> que permite modificar este comportamiento.</li>
<li>La cuarta linea indica qué variable ha sido asignada a cual método de muestreo. En este caso la información es redundante, ya que tenemos una sola variable, pero esto no siempre es así. PyMC permite combinar métodos de muestreo, ya sea de forma automática basado en propiedades de las variables a muestrear o especificado por el usuario usando el argumento <code>step</code>.</li>
<li>La quinta linea es una barra de progreso con varias métricas sobre la velocidad del muestreo, que en este caso (y para referencia futura) es muy alta. Tambiém indica la cantidad de cadenas usadas y la cantidad de divergencias. Tener 0 divergencias es ideal, más adelante discutiremos la razón.</li>
<li>Por último tenemos un detalle de la cantidad de muestras generadas, aunque pedimos 1000 obtuvimos 8000, la razón es que es son 1000 por cadena (4 cadenas en mi caso), es decir 4000. Todavía nos queda explicar 4000 muestras <em>extras</em>, estas se corresponden a 1000 por cadena y son muestras que PyMC utiliza para <em>auto-tunear</em> el método de muestreo. Estás muestras son luego descartadas automáticametne ya que no son muestras representativas del posterior. La cantidad de pasos que se usan para <em>tunear</em> el algoritmo de muestro se puede cambiar con el argumento <code>tune</code> de la función <code>pm.sample(.)</code>.</li>
</ul>
</section>
</section>
<section id="resumiendo-el-a-posteriori" class="level2">
<h2 class="anchored" data-anchor-id="resumiendo-el-a-posteriori">Resumiendo el <em>a posteriori</em></h2>
<p>Por lo general, la primer tarea a realizar luego de haber realizado un muestreo es evaluar como lucen los resultados. La función <code>plot_forestplot</code> de ArviZ es muy útil para esta tarea.</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>az.plot_forest(idata, combined<span class="op">=</span><span class="va">True</span>, figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">2</span>))<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="02_Programación_probabilística_files/figure-html/cell-8-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>El punto indica la media, la linea gruesa el rango intercuartial y las lineas finas el HDI 94%</p>
<blockquote class="blockquote">
<p>Es importante notar que la variable <code>y</code> es una variable observada, es decir conocida. Mientras que en gráfico anterior estamos dibujando solo <span class="math inline">\(\theta\)</span> que es la única variables desconocida, y por lo tanto muestreada.</p>
</blockquote>
<p>Si quisieramos un resúmen numérico de los resultados podemos usar:</p>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>az.summary(idata, kind<span class="op">=</span><span class="st">"stats"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="8">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>mean</th>
      <th>sd</th>
      <th>hdi_3%</th>
      <th>hdi_97%</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>θ</th>
      <td>0.333</td>
      <td>0.174</td>
      <td>0.046</td>
      <td>0.657</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>Como resultado obtenemos un DataFrame con los valores de la media, la desviación estándar y el intervalo HDI 94% (hdi_3 hdi_97).</p>
<p>Otra forma de resumir visualmente el a posteriori es usar la función <code>plot_posterior</code> que viene con ArviZ, ya hemos utilizado esta distribución en el capítulo anterior para un falso a posteriori. Vamos a usarlo ahora con un posterior real. Por defecto, esta función muestra un histograma para variables discretas y KDEs para variables continuas. También obtenemos la media de la distribución (podemos preguntar por la mediana o moda usando el argumento <code>point_estimate</code>) y el 94% HDI como una línea negra en la parte inferior de la gráfica. Se pueden establecer diferentes valores de intervalo para el HDI con el argumento <code>hdi_prob</code>. Este tipo de gráfica fue presentado por John K. Kruschke en su gran libro “Doing Bayesian Data Analysis”.</p>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>az.plot_posterior(idata)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="02_Programación_probabilística_files/figure-html/cell-10-output-1.png" class="img-fluid"></p>
</div>
</div>
</section>
<section id="decisiones-basadas-en-el-posterior" class="level2">
<h2 class="anchored" data-anchor-id="decisiones-basadas-en-el-posterior">Decisiones basadas en el posterior</h2>
<p>A veces describir el <em>a posteriori</em> no es suficiente, y es necesario tomar decisiones basadas en nuestras inferencias. Esto suele implicar reducir una estimación continua a una dicotómica: sí-no, enfermo-sano, contaminado-seguro, etc. Es posible, por ejemplo, que tengamos que decidir si la moneda está o no sesgada. Una moneda sesgada sería una que no caiga cara con probabilidad 0.5. Por lo tanto una forma de evaluar el sesgo es comparar el valor de referencia 0.5 contra el intervalo HPD. En la figura anterior, podemos ver que el HPD va de <span class="math inline">\(\approx 0.02\)</span> a <span class="math inline">\(\approx 0.71\)</span> y, por lo tanto, 0.5 está incluido en el HPD. Según el <em>a posterioriri</em> la moneda parece estar sesgada hacia las cecas, pero no podemos descartar por completo el valor de 0.5. Si esta conclusión nos deja sabor a poco entonces tendremos que recopilar más datos para así reducir la varianza del <em>a posteriori</em> o buscar información para definir un <em>a priori</em> más informativo.</p>
<section id="rope" class="level4">
<h4 class="anchored" data-anchor-id="rope">ROPE</h4>
<p>Estrictamente la probabilidad de observar el valor exacto de 0.5 es nula, además en la práctica no nos suele interesar tener precisión infinita si no que solemos tener una idea del rango de error que es tolerable o despreciable. Una posibilidad consiste en definir lo que se conoce como <em>región de equivalencia práctica</em> o ROPE (<em>Region Of Practical Equivalence</em>). Podríamos tener buenas razones para considerar que cualquier valor entre 0,45 y 0,55 es prácticamente equivalente a 0.5. No hay reglas generales para definir un ROPE ya que esta es una decisión contexto-dependiente. Para algunos problemas 0.05 podría ser mucho para otros poco, en algunos casos un rango simétrico es útil en otros es una mala idea.</p>
<p>Ya establecido la ROPE podemos usar las siguientes reglas para tomar una decisión:</p>
<ul>
<li><p>El valor de un parámetro es considerado improbable (o rechazado) si la totalidad de la ROPE cae por fuera del HPD 94% del parámetro en cuestión.</p></li>
<li><p>El valor de un parámetro es aceptado si la ROPE contiene por completo al HPD 94% del parámetro en cuestión.</p></li>
</ul>
<blockquote class="blockquote">
<p>Una ROPE es un intervalo arbitrario que se determina usando conocimiento previo y relevante sobre un tema. Cualquier valor dentro de este inervalo es considera equivalente.</p>
</blockquote>
<p>Usando la función <code>plot_posterior</code> de ArviZ, podemos graficar el posterior junto con el HPD y la ROPE.</p>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>az.plot_posterior(idata, rope<span class="op">=</span>[<span class="fl">0.45</span>, <span class="fl">.55</span>])<span class="op">;</span> </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="02_Programación_probabilística_files/figure-html/cell-11-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Otra herramienta que nos puede asistir en la toma de decisiones es comparar el <em>a posteriori</em> con un valor de referencia. La función <code>plot_posterior</code> también nos permite hacer esto:</p>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>az.plot_posterior(idata, ref_val<span class="op">=</span><span class="fl">0.5</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="02_Programación_probabilística_files/figure-html/cell-12-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>El valor de referencia está indicado con una linea turquesa, junto con la proporción del posterior por debajo y por arriba del valor de referencia.</p>
<p>Para una discusión más detallada del uso de la ROPE pueden leer el capítulo 12 del gran libro <em>“Doing Bayesian Data Analysis”</em> de John Kruschke. Este capítulo también discute cómo realizar pruebas de hipótesis de forma Bayesiana y los problemas de realizar este tipo de análisis, ya sea de forma Bayesiana o no-Bayesiana.</p>
</section>
<section id="funciones-de-perdida" class="level3">
<h3 class="anchored" data-anchor-id="funciones-de-perdida">Funciones de perdida</h3>
<p>Una alternativa más <em>formal</em> al uso de las ROPEs son las <strong>Funciones de pérdida</strong>. Para poder tomar la mejor decisión posible es necesario tener la mejor descripción posible de un problema y luego una evaluación correcta de los costos y beneficios. Bajo el marco Bayesiano lo primero implica obtener una distribución <em>a posteriori</em>, lo segundo se puede conseguir mediante la aplicación de una función de perdida. Una función de perdida es una forma de medir cuan distinta es una estimación respecto del valor <em>real</em> (o de referencia) de un parámetro. Algunos ejemplos comunes son:</p>
<ul>
<li>La perdida cuadrática <span class="math inline">\((\theta - \hat \theta)^2\)</span></li>
<li>La perdida absoluta $|- | $</li>
<li>La perdida 0-1 <span class="math inline">\(I(\theta \ne \hat{\theta})\)</span> siendo <span class="math inline">\(I\)</span> la función indicatriz</li>
</ul>
<p>La función de perdida (o su inversa) reciben diversos nombres según el campo de aplicación como funciones de costo, funciones objetivo, funciones de fitness (sic), funciones de utilidad, etc.</p>
<p>En la práctica generalmente desconocemos el valor correcto de <span class="math inline">\(\theta\)</span> y a duras penas tendremos un posterior adecuado, por lo tanto lo que se hace es tratar de encontrar el valor de <span class="math inline">\(\hat \theta\)</span> que minimice el <strong>valor esperado</strong> de la función de perdida. Esto implica promediar la función de perdida sobre todo el posterior, promediamos sobre el posterior porque desconocemos el valor de <span class="math inline">\(\theta\)</span>.</p>
<p>En el siguiente ejemplo tenemos dos funciones de pérdida. La función absoluta <code>lossf_a</code> y la cuadrática <code>lossf_b</code>. Evaluamos cada una de las funciones para distintos valores de <span class="math inline">\(\hat \theta\)</span> sobre una grilla de 500 puntos y encontramos el mínimo.</p>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>_, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">500</span>)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>θ_pos <span class="op">=</span> az.extract(idata, var_names<span class="op">=</span><span class="st">'θ'</span>)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>lossf_a <span class="op">=</span> [np.mean(<span class="bu">abs</span>(i <span class="op">-</span> θ_pos)) <span class="cf">for</span> i <span class="kw">in</span> grid]</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>lossf_b <span class="op">=</span> [np.mean((i <span class="op">-</span> θ_pos)<span class="op">**</span><span class="dv">2</span>) <span class="cf">for</span> i <span class="kw">in</span> grid]</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, (lossf, c) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>([lossf_a, lossf_b], [<span class="st">'C0'</span>, <span class="st">'C1'</span>])):</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    mini <span class="op">=</span> np.argmin(lossf)</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    ax.plot(grid, lossf, c)</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    ax.plot(grid[mini], lossf[mini], <span class="st">'o'</span>, color<span class="op">=</span>c, label<span class="op">=</span><span class="ss">f"función de perdida </span><span class="sc">{</span>[<span class="st">'a'</span>,<span class="st">'b'</span>][i]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    pos <span class="op">=</span> (np.<span class="bu">max</span>(lossf) <span class="op">-</span> np.<span class="bu">min</span>(lossf)) <span class="op">*</span> <span class="fl">0.05</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    ax.annotate(<span class="ss">f"</span><span class="sc">{</span>grid[mini]<span class="sc">:.2f}</span><span class="ss">"</span>, (grid[mini], lossf[mini] <span class="op">+</span> pos), color<span class="op">=</span>c)</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    ax.set_yticks([])</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    ax.set_xlabel(<span class="vs">r'$\hat \theta$'</span>)</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    ax.legend()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="02_Programación_probabilística_files/figure-html/cell-13-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Las curvas son similares entre sí e incluso los mínimos son simialres, <span class="math inline">\(\hat{\theta} \approx 0.31\)</span> para <code>lossf_a</code> y <span class="math inline">\(\hat{\theta} \approx 0.33\)</span> para <code>lossf_b</code></p>
<p>Lo que es interesante es que el primer valor se corresponde con la mediana del posterior y el segundo con su media.</p>
<div class="cell" data-scrolled="true" data-execution_count="13">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>np.median(θ_pos).item(), np.mean(θ_pos).item()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="13">
<pre><code>(0.3130652518233671, 0.33292653125228294)</code></pre>
</div>
</div>
<p>Si bien esto no es una prueba formal, espero que haya sido un ejemplo lo suficientemente claro como para ilustrar el mensaje más importante de esta sección:</p>
<blockquote class="blockquote">
<p>Diferentes funciones de pérdida se relacionan con diferentes estimaciones puntuales</p>
</blockquote>
<p>Por lo tanto, si queremos ser formales al momento de computar una estimación puntual, debemos decidir qué función de costo utilizar. O a la inversa, si elegimos una estimación puntual implicitamente estamos eligiendo una función de pérdida.</p>
<p>La ventaja de elegir explicitamente una función de perdida es que podemos ajustarla a las necesidades de un problema particular, en vez de utilizar un criterio predefinido. En muchos casos el costo asociado a una toma de decisión es asimétrico, esto es común en salud pública como sucede con vacunas o con la interrupción voluntaria del embarazo; procedimientos simples, baratos y seguros que previenen una gran cantidad de inconvenientes con un bajo riesgo de complicaciones.</p>
<p>Dado que, en general, el <em>a posteriori</em> toma la forma de muestras finitas almacenadas en una computadora, es posible escribir código que refleje funciones de perdidas sin necesidad de estar acotado por la conveniencia matemática o la simplicidad. El siguiente es un ejemplo bastante pavo de esto.</p>
<div class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>lossf <span class="op">=</span> []</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> grid:</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    f <span class="op">=</span> np.cos(i) <span class="op">*</span> (<span class="dv">1</span><span class="op">-</span>i) <span class="op">+</span> np.sin(i) <span class="op">*</span> (i)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    lossf.append(f)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>mini <span class="op">=</span> np.argmin(lossf)</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>plt.plot(grid, lossf)</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>plt.plot(grid[mini], lossf[mini], <span class="st">'o'</span>)</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>pos <span class="op">=</span> (np.<span class="bu">max</span>(lossf) <span class="op">-</span> np.<span class="bu">min</span>(lossf)) <span class="op">*</span> <span class="fl">0.05</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>plt.annotate(<span class="ss">f"</span><span class="sc">{</span>grid[mini]<span class="sc">:.2f}</span><span class="ss">"</span>, (grid[mini], lossf[mini] <span class="op">+</span> pos))</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>plt.yticks([])</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="vs">r'$\hat \theta$'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="02_Programación_probabilística_files/figure-html/cell-15-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Ahora bien, en la práctica no es cierto que todo el mundo elija una estimación puntual porque realmente acuerda, o tiene presente, alguna función de perdida en particular, en general la elección es por conveniencia, o tradición. Se usa la mediana porque es más robusta que la media a valores extremos o se usa la media porque es un concepto familiar y simple de entender, o porque pensamos que tal o cual observable es realmente un promedio de algún fenómeo subyacente (como moléculas golpeandose entre sí o genes interactuando con el ambiente).</p>
</section>
</section>
<section id="modelos-multiparamétricos" class="level2">
<h2 class="anchored" data-anchor-id="modelos-multiparamétricos">Modelos Multiparamétricos</h2>
<p>Prácticamente todos los modelos de interés en estadística, son multiparamétricos, es decir modelos con más de un parámetro.</p>
<p>Suele suceder que no todos los parámetros requeridos para construir un modelo son de interés, supongamos que quisiéramos estimar el valor medio de una distribución Gaussiana, a menos que sepamos el valor <em>real</em> de la desviación estándar, nuestro modelo deberá contener un parámetro para la media y uno para la desviación estándar. Los parámetros que no son de inmediato interés pero son necesarios para definir un modelo de forma completa se llaman <em>nuisance parameters</em> (o parámetro estorbo).</p>
<p>En estadística Bayesiana todos los parámetros tienen el mismo estatus, por lo que la diferencia entre <em>nuisance</em> o no <em>nuisance</em> no es fundamental bajo ningún concepto, sino que depende completamente de nuestras preguntas.</p>
<p>En principio podría parecer que incorporar parámetros que no nos interesan es un ejercicio de futilidad. Sin embargo, es todo lo contrario, al incorporar estos parámetros permitimos que la incertidumbre que tenemos sobre ellos se propague de forma adecuada a los resultados.</p>
<section id="inferencias-lumínicas" class="level3">
<h3 class="anchored" data-anchor-id="inferencias-lumínicas">Inferencias lumínicas</h3>
<p>A finales del siglo XIX Simon Newcomb realizó varios experimentos para determinar la velocidad de la luz. En uno de ellos Newcomb midió el tiempo que le tomaba a la luz recorrer 7442 metros.</p>
<p>A continuación se muestra sus resultados, 66 mediciones.</p>
<div class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>datos <span class="op">=</span> np.array([<span class="fl">248.28</span>, <span class="fl">248.26</span>, <span class="fl">248.33</span>, <span class="fl">248.24</span>, <span class="fl">248.34</span>, <span class="fl">247.56</span>, <span class="fl">248.27</span>, <span class="fl">248.16</span>,</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>                  <span class="fl">248.4</span>, <span class="fl">247.98</span>, <span class="fl">248.29</span>, <span class="fl">248.22</span>, <span class="fl">248.24</span>, <span class="fl">248.21</span>, <span class="fl">248.25</span>, <span class="fl">248.3</span>,</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>                  <span class="fl">248.23</span>, <span class="fl">248.29</span>, <span class="fl">248.31</span>, <span class="fl">248.19</span>, <span class="fl">248.24</span>, <span class="fl">248.2</span>, <span class="fl">248.36</span>, <span class="fl">248.32</span>,</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>                  <span class="fl">248.36</span>, <span class="fl">248.28</span>, <span class="fl">248.25</span>, <span class="fl">248.21</span>, <span class="fl">248.28</span>, <span class="fl">248.29</span>, <span class="fl">248.37</span>, <span class="fl">248.25</span>,</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>                  <span class="fl">248.28</span>, <span class="fl">248.26</span>, <span class="fl">248.3</span>, <span class="fl">248.32</span>, <span class="fl">248.36</span>, <span class="fl">248.26</span>, <span class="fl">248.3</span>, <span class="fl">248.22</span>,</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>                  <span class="fl">248.36</span>, <span class="fl">248.23</span>, <span class="fl">248.27</span>, <span class="fl">248.27</span>, <span class="fl">248.28</span>, <span class="fl">248.27</span>, <span class="fl">248.31</span>, <span class="fl">248.27</span>,</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>                  <span class="fl">248.26</span>, <span class="fl">248.33</span>, <span class="fl">248.26</span>, <span class="fl">248.32</span>, <span class="fl">248.32</span>, <span class="fl">248.24</span>, <span class="fl">248.39</span>, <span class="fl">248.28</span>,</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>                  <span class="fl">248.24</span>, <span class="fl">248.25</span>, <span class="fl">248.32</span>, <span class="fl">248.25</span>, <span class="fl">248.29</span>, <span class="fl">248.27</span>, <span class="fl">248.28</span>, <span class="fl">248.29</span>,</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>                  <span class="fl">248.16</span>, <span class="fl">248.23</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Si graficamos estas medidas veremos que la distribución parece Gaussiana excepto por dos medidas inusualmente bajas.</p>
<div class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> az.plot_kde(datos, rug<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>ax.set_yticks([])<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="02_Programación_probabilística_files/figure-html/cell-17-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Por simplicidad vamos a suponer que los datos siguen una distribución Gaussiana, después de todo es lo que en general se esperaría, en general, al medir una misma <em>cosa</em> varias veces. Una distribución Gaussiana queda definida por dos parámetros, la media y la desviación estándar, como desconocemos estas dos cantidades necesitamos establecer dos <em>a prioris</em> uno para cada parámetro. Un modelo probabilístico razonable sería el siguiente.</p>
<p><span class="math display">\[\begin{align}
\mu &amp;\sim U(l, h) \\
\sigma &amp;\sim \mathcal{HN}(\sigma_{\sigma}) \\
y &amp;\sim \mathcal{N}(\mu, \sigma)
\end{align}\]</span></p>
<p>Es decir, <span class="math inline">\(\mu\)</span> proviene de una distribución uniforme entre los límites <span class="math inline">\(l\)</span> y <span class="math inline">\(h\)</span> y <span class="math inline">\(\sigma\)</span> proviene de una media-normal (<em>half-normal</em>) con desviación estándar <span class="math inline">\(\sigma_{\sigma}\)</span>, esta distribución es como una Gaussiana pero restringida al rango <span class="math inline">\([0, \infty]\)</span>. Por último los datos <span class="math inline">\(y\)</span>, como dijimos anteriormente, proviene de una distribución normal, especificada por <span class="math inline">\(\mu\)</span> y <span class="math inline">\(\sigma\)</span>.</p>
<p>Si desconocemos por completo cuales podrían ser los valores de <span class="math inline">\(\mu\)</span> y de <span class="math inline">\(\sigma\)</span>, podemos fijar valores para los <em>a prioris</em> que reflejen nuestra ignorancia.</p>
<p>Para la distribución uniforme una opción podría ser un intervalo con límite inferior de 0 y superior de 1 segundo. El límite inferior de 0 tiene sentido ya que las velocidades no pueden ser negativas, el límite superior de un 1 segundo es un valor elevado en la escala de los datos. Otra posibilidad sería usar los datos como guía por ejemplo <span class="math inline">\((l=datos.min() / 100, h=l+datos.min() * 100)\)</span>. De esta forma garantizamos que el <em>a priori</em> contenga el rango de los datos pero que sea mucho más amplio, reflejando que no tenemos demasiado información para fijar un <em>a priori</em> de forma más precisa. Los Bayesianos puristas consideran usar los datos para estimar <em>los a prioris</em> ¡como alta traición! Ojo con las almas de cristal (¡en todo ámbito!).</p>
<p>Bajo ciertas condiciones los <em>a prioris</em> uniformes puede ser problemáticos, tanto desde el punto de vista estadístico como computacional, por lo que se recomienda evitarlos, en general se recomienda evitar <em>a prioris</em> con <strong>límites</strong>, como la distribución uniforme, a menos que tengamos información confiable sobre esos límites. Por ejemplo sabemos que las probabilidades están restringidas al intervalo [0, 1]. Pero no hay una buena razón para limitar la velocidad de la luz (bueno ¡no la había en los tiempos de Newcomb!).</p>
<p>En la siguiente celda podrán ver que he elegido un par de <em>a prioris</em> y hay otros comentados. Comparen cómo corre el modelo con los distintos <em>a prioris</em>, tanto en términos de los resultados como los tiempos y <em>calidad</em> del muestreo.</p>
<div class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> modelo_g:</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># los a prioris</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    μ <span class="op">=</span> pm.Uniform(<span class="st">'μ'</span>, <span class="dv">240</span>, <span class="dv">250</span>)</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">#μ = pm.Normal('μ', 240, 100) # otro a priori alternativo</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    σ <span class="op">=</span> pm.HalfNormal(<span class="st">'σ'</span>, sigma<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">#σ = pm.HalfNormal('σ', sigma=datos.std() * 100)</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># el likelihood</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> pm.Normal(<span class="st">'y'</span>, mu<span class="op">=</span>μ, sigma<span class="op">=</span>σ, observed<span class="op">=</span>datos)</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    idata_g <span class="op">=</span> pm.sample()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (4 chains in 4 jobs)
NUTS: [μ, σ]</code></pre>
</div>
<div class="cell-output cell-output-display">

<style>
    /* Turns off some styling */
    progress {
        /* gets rid of default border in Firefox and Opera. */
        border: none;
        /* Needs to be in here for Safari polyfill so background images work as expected. */
        background-size: auto;
    }
    progress:not([value]), progress:not([value])::-webkit-progress-bar {
        background: repeating-linear-gradient(45deg, #7e7e7e, #7e7e7e 10px, #5c5c5c 10px, #5c5c5c 20px);
    }
    .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
        background: #F44336;
    }
</style>
</div>
<div class="cell-output cell-output-display">

    <div>
      <progress value="8000" class="" max="8000" style="width:300px; height:20px; vertical-align: middle;"></progress>
      100.00% [8000/8000 00:01&lt;00:00 Sampling 4 chains, 0 divergences]
    </div>
    
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Sampling 4 chains for 1_000 tune and 1_000 draw iterations (4_000 + 4_000 draws total) took 1 seconds.</code></pre>
</div>
</div>
<p>Como se puede ver el plot-posterior tiene ahora dos subpaneles, una por cada parámetro. Cada uno se corresponde a una variable <em>marginal</em> del <em>a posteriori</em> que en este caso es bi-dimensional.</p>
<div class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>az.plot_posterior(idata_g)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="02_Programación_probabilística_files/figure-html/cell-19-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>La siguiente figura muestra la distribución <em>a posteriori</em> (que como ya mencionamos en bidimensional), junto con las distribuciones marginales para los parámetros <span class="math inline">\(\mu\)</span> y <span class="math inline">\(\sigma\)</span>.</p>
<div class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>az.plot_pair(idata_g, kind<span class="op">=</span><span class="st">'kde'</span>, marginals<span class="op">=</span><span class="va">True</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="02_Programación_probabilística_files/figure-html/cell-20-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Una vez computado el <em>a posteriori</em> podemos realizar diversos cálculos a partir de él. Uno de esos cálculos consiste en <em>simular datos</em> (<span class="math inline">\(\tilde{y}\)</span>). Matemáticamente lo que queremos calcular es:</p>
<p><span class="math display">\[\begin{equation}
p(\tilde{y} \,|\, y) = \int p(\tilde{y} \,|\, \theta) \, p(\theta \,|\, y) \, d\theta
\end{equation}\]</span></p>
<p>donde:</p>
<p><span class="math inline">\(y\)</span> son los datos observados mientras que <span class="math inline">\(\theta\)</span> corresponde a los parámetros del modelo.</p>
<p>Siguiendo el ejemplo de la velocidad de la luz, <span class="math inline">\(\theta\)</span> corresponde a <span class="math inline">\(\mu\)</span> y a <span class="math inline">\(\sigma\)</span>. Computacionalmente podemos obtener <span class="math inline">\(\tilde{y}\)</span> de la siguiente forma:</p>
<ol type="1">
<li>Elegimos una muestra al azar de las generadas por PyMC (un valor para <span class="math inline">\(\mu_i\)</span> y <span class="math inline">\(\sigma_i\)</span>)</li>
<li>Generamos un <em>dato sintético</em> usando el mismo <em>likelihood</em> que usamos en el modelo, en este caso <span class="math inline">\(\tilde{y_i} \sim N(\mu_i, \sigma_i)\)</span></li>
<li>Repetimos 1 y 2 hasta obtener la cantidad requerida de muestras.</li>
</ol>
<p>Usando PyMC podemos calcular esto llamando a la función <code>sample_ppc</code>. El siguiente código devuelve 100 predicciones cada una de ellas de igual tamaño al de los datos.</p>
<div class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>ppc_g <span class="op">=</span> pm.sample_posterior_predictive(idata_g, model<span class="op">=</span>modelo_g)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Sampling: [y]</code></pre>
</div>
<div class="cell-output cell-output-display">

<style>
    /* Turns off some styling */
    progress {
        /* gets rid of default border in Firefox and Opera. */
        border: none;
        /* Needs to be in here for Safari polyfill so background images work as expected. */
        background-size: auto;
    }
    progress:not([value]), progress:not([value])::-webkit-progress-bar {
        background: repeating-linear-gradient(45deg, #7e7e7e, #7e7e7e 10px, #5c5c5c 10px, #5c5c5c 20px);
    }
    .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
        background: #F44336;
    }
</style>
</div>
<div class="cell-output cell-output-display">

    <div>
      <progress value="4000" class="" max="4000" style="width:300px; height:20px; vertical-align: middle;"></progress>
      100.00% [4000/4000 00:00&lt;00:00]
    </div>
    
</div>
</div>
<p>Los datos simulados los podemos usar para compararlos con los datos observados y de esta forma evaluar el modelo. Esto se conoce como prueba predictivas <em>a posteriori</em>, como ya adelantamos algo en el capítulo anterior. En la siguiente gráfica la linea negra corresponde a los datos observados mientras que las lineas azules (semitrasparentes) corresponden a datos predichos por el modelo.</p>
<div class="cell" data-scrolled="true" data-execution_count="21">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>az.plot_ppc(ppc_g, num_pp_samples<span class="op">=</span><span class="dv">200</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="02_Programación_probabilística_files/figure-html/cell-22-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Según la gráfica anterior ¿Cuán bueno considerás que es nuestro modelo?</p>
</section>
<section id="modelos-robustos" class="level3">
<h3 class="anchored" data-anchor-id="modelos-robustos">Modelos robustos</h3>
<p>Un problema con el modelo anterior es que asume una distribución normal pero tenemos dos puntos que caen muy alejados de los valores medios. Esos puntos podrían estar alejados debido a errores experimentales en la toma de esos dos datos o podría haber un error al registrarlos o al trascribirlos. Si algo de esto sucedió podríamos justificar su eliminación de nuestro conjunto de datos (dejando registro de la eliminación y de las razones por las cuales lo hicimos). Otra opción es usar el rango inter-cuartil (u otro método <em>estadístico</em>) para declarar esos dos puntos como datos aberrantes ¡y desterrarlos de nuestros datos! Otra opción es dejarlos pero utilizar un modelo más robusto a valores alejados de la media.</p>
<p>Uno de los inconvenientes al asumir normalidad, es que la media es muy sensible a valores aberrantes. La razón está en la colas de la Gaussiana, aún cuando las colas se extienden de <span class="math inline">\(-\infty\)</span> a <span class="math inline">\(\infty\)</span>, la probabilidad de encontrar un valor cae rápidamente a medida que nos alejamos de la media, como se puede apreciar en la siguiente tabla que indica el porcentaje de valores que se encuentra a medida que nos alejamos de la media en unidades de desviación estándar (sd).</p>
<table class="table">
<thead>
<tr class="header">
<th>sd</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>%</td>
<td>68</td>
<td>95</td>
<td>99.7</td>
<td>99.994</td>
<td>99.99994</td>
</tr>
</tbody>
</table>
<p>Una alternativa a la distribución Gaussiana es usar una distribución t de Student, lo interesante de esta distribución es que además de estar definida por una media y una escala (análogo de la desviación estándar) está definida por un parámetro <span class="math inline">\(\nu\)</span>, usualmente llamado grados de libertad, o <em>grados de normalidad</em>, ya que <span class="math inline">\(\nu\)</span> controla cuan <em>pesadas</em> son las colas de la distribución. Cuando <span class="math inline">\(\nu = 1\)</span> (la distribución se llama de Cauchy o de Lorentz) las colas son muy pesadas, el 95% de los puntos está entre -12,7 y 12,7, en cambio en una Gaussiana (con desviación estándar 1) esto ocurre entre -1,96 y 1,96. En el límite de <span class="math inline">\(\nu\)</span> tendiendo a infinito estamos en presencia de una Gaussiana. La distribución t es realmente particular, cuando <span class="math inline">\(\nu &lt;= 1\)</span> la distribución no tiene media definida y la varianza solo está definida para valores de <span class="math inline">\(\nu &gt; 2\)</span>.</p>
<p>La siguiente figura muestra una distribución t de Student para distintos valores de <span class="math inline">\(\nu\)</span>.</p>
<div class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>_, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">5</span>))</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>x_values <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">500</span>)</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df <span class="kw">in</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">20</span>, np.inf]:</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    ax <span class="op">=</span> pz.Student(df, <span class="dv">0</span>, <span class="dv">1</span>).plot_pdf(support<span class="op">=</span>(<span class="op">-</span><span class="dv">7</span>, <span class="dv">7</span>))</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>ax.legend(loc<span class="op">=</span><span class="st">"center left"</span>, bbox_to_anchor<span class="op">=</span>(<span class="fl">0.65</span>, <span class="fl">0.5</span>))<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="02_Programación_probabilística_files/figure-html/cell-23-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Ahora que conocemos la distribución t de Student, podemos usarla en nuestro modelo:</p>
<p><span class="math display">\[\begin{align}
\mu &amp;\sim U(l, h) \\
\sigma &amp;\sim \mathcal{HN}(\sigma_h) \\
\nu &amp;\sim Expon(\lambda) \\
y &amp;\sim StudentT(\mu, \sigma, \nu)
\end{align}\]</span></p>
<p>En algunos modelos puede ser buena idea sumar 1 a la distribución exponencial a fin de asegurarse que <span class="math inline">\(\nu \ge 1\)</span> . En principio <span class="math inline">\(\nu\)</span> puede tomar valores de [0, <span class="math inline">\(\infty]\)</span>, pero en mi experiencia valores de <span class="math inline">\(\nu &lt; 1\)</span> pueden traer problemas durante el muestreo, ya que pueden aparecer valores demasiado alejados de la media (las colas son extremadamente gordas!). Esto puede ocurrir con modelos con datos <em>marcadamente aberrantes</em>, veremos un ejemplo de esto en el capítulo 4.</p>
<p>Gráficamente:</p>
<p><img src="img/velocidad_luz_t.png" width="400"></p>
<div class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> modelo_t:</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># los a prioris</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    μ <span class="op">=</span> pm.Uniform(<span class="st">'μ'</span>, <span class="dv">240</span>, <span class="dv">250</span>)</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    σ <span class="op">=</span> pm.HalfNormal(<span class="st">'σ'</span>, sigma<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    ν <span class="op">=</span> pm.Exponential(<span class="st">'ν'</span>, <span class="dv">1</span><span class="op">/</span><span class="dv">30</span>)</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># el likelihood</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> pm.StudentT(<span class="st">'y'</span>, mu<span class="op">=</span>μ, sigma<span class="op">=</span>σ, nu<span class="op">=</span>ν, observed<span class="op">=</span>datos)</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>    idata_t <span class="op">=</span> pm.sample()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (4 chains in 4 jobs)
NUTS: [μ, σ, ν]</code></pre>
</div>
<div class="cell-output cell-output-display">

<style>
    /* Turns off some styling */
    progress {
        /* gets rid of default border in Firefox and Opera. */
        border: none;
        /* Needs to be in here for Safari polyfill so background images work as expected. */
        background-size: auto;
    }
    progress:not([value]), progress:not([value])::-webkit-progress-bar {
        background: repeating-linear-gradient(45deg, #7e7e7e, #7e7e7e 10px, #5c5c5c 10px, #5c5c5c 20px);
    }
    .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
        background: #F44336;
    }
</style>
</div>
<div class="cell-output cell-output-display">

    <div>
      <progress value="8000" class="" max="8000" style="width:300px; height:20px; vertical-align: middle;"></progress>
      100.00% [8000/8000 00:02&lt;00:00 Sampling 4 chains, 0 divergences]
    </div>
    
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Sampling 4 chains for 1_000 tune and 1_000 draw iterations (4_000 + 4_000 draws total) took 3 seconds.</code></pre>
</div>
</div>
<p>Comparemos las estimaciones entre ambos modelos</p>
<div class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>az.summary(idata_g)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="24">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>mean</th>
      <th>sd</th>
      <th>hdi_3%</th>
      <th>hdi_97%</th>
      <th>mcse_mean</th>
      <th>mcse_sd</th>
      <th>ess_bulk</th>
      <th>ess_tail</th>
      <th>r_hat</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>μ</th>
      <td>248.262</td>
      <td>0.014</td>
      <td>248.236</td>
      <td>248.288</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>3807.0</td>
      <td>2568.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>σ</th>
      <td>0.110</td>
      <td>0.010</td>
      <td>0.093</td>
      <td>0.128</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>3152.0</td>
      <td>2502.0</td>
      <td>1.0</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<div class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>az.summary(idata_t)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="25">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>mean</th>
      <th>sd</th>
      <th>hdi_3%</th>
      <th>hdi_97%</th>
      <th>mcse_mean</th>
      <th>mcse_sd</th>
      <th>ess_bulk</th>
      <th>ess_tail</th>
      <th>r_hat</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>μ</th>
      <td>248.274</td>
      <td>0.006</td>
      <td>248.261</td>
      <td>248.286</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>3695.0</td>
      <td>2895.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>σ</th>
      <td>0.041</td>
      <td>0.007</td>
      <td>0.029</td>
      <td>0.054</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>2413.0</td>
      <td>2620.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>ν</th>
      <td>2.599</td>
      <td>0.922</td>
      <td>1.178</td>
      <td>4.280</td>
      <td>0.019</td>
      <td>0.013</td>
      <td>2502.0</td>
      <td>2569.0</td>
      <td>1.0</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>En este caso, vemos que la estimación de <span class="math inline">\(\mu\)</span> es muy similar entre los dos modelos, aunque la estimación de <span class="math inline">\(\sigma\)</span>, pasó de ser de ~10 a ~4. Esto es consecuencia de que la distribución t asigna menos peso a los valores alejados de la media que la distribución Gaussiana.</p>
<p>Hagamos un prueba predictiva <em>a posteriori</em> para el nuevo modelo.</p>
<div class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>ppc_t <span class="op">=</span> pm.sample_posterior_predictive(idata_t, model<span class="op">=</span>modelo_t)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Sampling: [y]</code></pre>
</div>
<div class="cell-output cell-output-display">

<style>
    /* Turns off some styling */
    progress {
        /* gets rid of default border in Firefox and Opera. */
        border: none;
        /* Needs to be in here for Safari polyfill so background images work as expected. */
        background-size: auto;
    }
    progress:not([value]), progress:not([value])::-webkit-progress-bar {
        background: repeating-linear-gradient(45deg, #7e7e7e, #7e7e7e 10px, #5c5c5c 10px, #5c5c5c 20px);
    }
    .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
        background: #F44336;
    }
</style>
</div>
<div class="cell-output cell-output-display">

    <div>
      <progress value="4000" class="" max="4000" style="width:300px; height:20px; vertical-align: middle;"></progress>
      100.00% [4000/4000 00:00&lt;00:00]
    </div>
    
</div>
</div>
<div class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>az.plot_ppc(ppc_t, num_pp_samples<span class="op">=</span><span class="dv">200</span>)</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="dv">247</span>, <span class="dv">250</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="02_Programación_probabilística_files/figure-html/cell-28-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>¿Qué conclusión se puede sacar de comparar esta prueba predictiva a posteriori con la anterior?</p>
</section>
<section id="accidentes-mineros" class="level3">
<h3 class="anchored" data-anchor-id="accidentes-mineros">Accidentes mineros</h3>
<p>Este ejemplo está tomado del <a href="https://www.pymc.io/projects/docs/en/latest/learn/core_notebooks/pymc_overview.html#case-study-2-coal-mining-disasters">tutorial</a> de PyMC.</p>
<p>El problema es el siguiente, tenemos un registro del número de accidentes en minas de carbón, ubicadas en el Reino Unido, que ocurrieron entre 1851 y 1962 (<a href="http://biomet.oxfordjournals.org/content/66/1/191.abstract">Jarrett, 1979</a>). Se sospecha que la aplicación de ciertas regulaciones de seguridad tuvo como efecto una disminución en la cantidad de catástrofes. Por lo tanto nos interesa averiguar el año en que la tasa cambió y nos interesa estimar ambas tasas.</p>
<p>Los datos son los siguientes, por un lado tenemos la variable <em>accidentes</em> que contiene la cantidad de accidentes por año y por el otro la variable <em>años</em> conteniendo el rango de años para los cuales tenemos datos. Si prestan atención verán que <em>accidentes</em> es un arreglo enmascarado (o <em>masked array</em>). Esto es un tipo especial de arreglo de NumPy donde cada elemento del arreglo contiene asociado un valor <em>True</em> o <em>False</em> el cual indica si el elemento debe o no ser usado durante cualquier tipo de operación. En este caso como faltan datos para dos años lo que se ha hecho es marcar esa falta de datos con un valor centinela de -999, esta es la forma de indicarle a PyMC la presencia de datos faltantes, alternativamente se pueden pasar los datos como un <em>dataframe</em> de Pandas conteniendo el valor especial <code>NAN</code> (que es el valor por defecto en Pandas para lidiar con datos faltantes).</p>
<p>Bien, pero para que molestarse con datos faltantes si en general es más fácil eliminarlos. una de las razones es que esto puede conducir a pérdida de información cuando por cada observación tenemos más de una variable o cantidad de interés. Por ejemplo si tenemos 50 sujetos a los que les hemos medido la presión, la temperatura y el ritmo cardíaco, pero sucede que para 4 de ellos no contamos con el datos de la presión (porque alguien se olvidó de medirlo o registrarlo, o porque el tensiómetro se rompió, o por lo que sea). Podemos eliminar esos cuatro sujetos del análisis y perder por lo tanto información sobre la presión y ritmo cardíaco, o podemos usar todos los datos disponibles y además estimar los valores de temperatura faltantes. En el contexto de la estadística Bayesiana los datos faltantes se tratan como un parámetro desconocido del modelo que puede ser estimado.</p>
<div class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>accidentes <span class="op">=</span> pd.Series([<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">4</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">0</span>, <span class="dv">6</span>, <span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">6</span>,</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>                       <span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">5</span>,</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>                       <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">3</span>, np.nan, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">0</span>,</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>                       <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>,</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>                       <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">2</span>,</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>                       <span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">1</span>, np.nan, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">4</span>,</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>                       <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>])</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>años <span class="op">=</span> np.arange(<span class="dv">1851</span>, <span class="dv">1962</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>plt.plot(años, accidentes, <span class="st">'.'</span>)</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Número de accidentes"</span>)</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Año"</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="02_Programación_probabilística_files/figure-html/cell-30-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Para modelar los accidentes usaremos una distribución de Poisson. Como creemos que la cantidad media de accidentes es distinta antes y después de la introducción de regulaciones de seguridad usaremos dos valores de tasas medias de accidentes (<span class="math inline">\(t_0\)</span> y <span class="math inline">\(t_1\)</span>). Además deberemos estimar un punto de corte (<span class="math inline">\(pc\)</span>) que dividirá los años para los cuales se aplica la tasa de accidentes <span class="math inline">\(t_0\)</span> de los cuales se aplica la tasa <span class="math inline">\(t_1\)</span>:</p>
<p><span class="math display">\[\begin{equation}
A_t \sim Poisson(tasa)
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
tasa = \begin{cases}
t_0, \text{si } t \ge pc,\\
t_1, \text{si } t \lt pc
\end{cases}
\end{equation}\]</span></p>
<p>Los <em>a prioris</em> que usaremos serán:</p>
<p><span class="math display">\[\begin{align}
t_0 \sim Expon(1) \\
t_1 \sim Expon(1) \\
pc \sim U(A_0, A_1)
\end{align}\]</span></p>
<p>Donde la distribucion uniforme es discreta y <span class="math inline">\(A_0\)</span> y <span class="math inline">\(A_1\)</span> corresponden al primer y último año considerado en el análisis respectivamente.</p>
<p>Gráficamente el modelo es:</p>
<p><img src="img/modelo_mineros.png" width="350"></p>
<p>Una peculiaridad de la implementación de este modelo en PyMC es el uso de la función <code>pm.switch</code> (linea 10). Esta es en realidad una función de PyMC y equivale a un <em>if else</em> de Python. Si el primer argumento es <em>True</em> entonces devuelve el segundo argumento caso contrario el tercer argumento. Como resultado tenemos que <em>tasa</em> es un vector de longitud igual a la de <em>años</em> y cuyos elementos corresponden a una repetición <span class="math inline">\(t_0\)</span> seguida de una repetición <span class="math inline">\(t_1\)</span>, la cantidad exacta de repeticiones de <span class="math inline">\(t_0\)</span> y <span class="math inline">\(t_1\)</span> está controlada por la condición <span class="math inline">\(pc \ge\)</span> <em>años</em>. De esta forma, podemos al muestrear <span class="math inline">\(pc\)</span>, modificar que años reciben cual tasa para el cálculo del <em>likelihood</em>.</p>
<div class="cell" data-execution_count="30">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> modelo_cat:</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>    pc <span class="op">=</span> pm.DiscreteUniform(<span class="st">'pc'</span>, lower<span class="op">=</span>años.<span class="bu">min</span>(), upper<span class="op">=</span>años.<span class="bu">max</span>())</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Priors para las tasas antes y después del cambio.</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>    t_0 <span class="op">=</span> pm.Exponential(<span class="st">'t_0'</span>, <span class="dv">1</span>)</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>    t_1 <span class="op">=</span> pm.Exponential(<span class="st">'t_1'</span>, <span class="dv">1</span>)</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Asignamos las tasas a los años de acuerdo a pc</span></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>    tasa <span class="op">=</span> pm.Deterministic(<span class="st">"tasa"</span>, pm.math.switch(pc <span class="op">&gt;=</span> años, t_0, t_1))</span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a>    acc <span class="op">=</span> pm.Poisson(<span class="st">'acc'</span>, tasa, observed<span class="op">=</span>accidentes)</span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a>    idata_cat <span class="op">=</span> pm.sample(<span class="dv">1000</span>, random_seed<span class="op">=</span><span class="dv">1791</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>/home/osvaldo/anaconda3/envs/bayes/lib/python3.9/site-packages/pymc/model.py:1406: ImputationWarning: Data in acc contains missing values and will be automatically imputed from the sampling distribution.
  warnings.warn(impute_message, ImputationWarning)
Multiprocess sampling (4 chains in 4 jobs)
CompoundStep
&gt;CompoundStep
&gt;&gt;Metropolis: [pc]
&gt;&gt;Metropolis: [acc_missing]
&gt;NUTS: [t_0, t_1]</code></pre>
</div>
<div class="cell-output cell-output-display">

<style>
    /* Turns off some styling */
    progress {
        /* gets rid of default border in Firefox and Opera. */
        border: none;
        /* Needs to be in here for Safari polyfill so background images work as expected. */
        background-size: auto;
    }
    progress:not([value]), progress:not([value])::-webkit-progress-bar {
        background: repeating-linear-gradient(45deg, #7e7e7e, #7e7e7e 10px, #5c5c5c 10px, #5c5c5c 20px);
    }
    .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
        background: #F44336;
    }
</style>
</div>
<div class="cell-output cell-output-display">

    <div>
      <progress value="8000" class="" max="8000" style="width:300px; height:20px; vertical-align: middle;"></progress>
      100.00% [8000/8000 00:02&lt;00:00 Sampling 4 chains, 0 divergences]
    </div>
    
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Sampling 4 chains for 1_000 tune and 1_000 draw iterations (4_000 + 4_000 draws total) took 2 seconds.</code></pre>
</div>
</div>
<div class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> az.plot_posterior(idata_cat, var_names<span class="op">=</span>[<span class="st">"~tasa"</span>], figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">6</span>))<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="02_Programación_probabilística_files/figure-html/cell-32-output-1.png" class="img-fluid"></p>
</div>
</div>
<div class="cell" data-execution_count="32">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>az.summary(idata_cat, var_names<span class="op">=</span>[<span class="st">"~tasa"</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="32">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>mean</th>
      <th>sd</th>
      <th>hdi_3%</th>
      <th>hdi_97%</th>
      <th>mcse_mean</th>
      <th>mcse_sd</th>
      <th>ess_bulk</th>
      <th>ess_tail</th>
      <th>r_hat</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>pc</th>
      <td>1889.971</td>
      <td>2.430</td>
      <td>1885.000</td>
      <td>1894.000</td>
      <td>0.168</td>
      <td>0.119</td>
      <td>224.0</td>
      <td>232.0</td>
      <td>1.01</td>
    </tr>
    <tr>
      <th>acc_missing[0]</th>
      <td>2.379</td>
      <td>1.879</td>
      <td>0.000</td>
      <td>6.000</td>
      <td>0.097</td>
      <td>0.069</td>
      <td>364.0</td>
      <td>467.0</td>
      <td>1.01</td>
    </tr>
    <tr>
      <th>acc_missing[1]</th>
      <td>0.931</td>
      <td>0.983</td>
      <td>0.000</td>
      <td>3.000</td>
      <td>0.038</td>
      <td>0.028</td>
      <td>704.0</td>
      <td>827.0</td>
      <td>1.00</td>
    </tr>
    <tr>
      <th>t_0</th>
      <td>3.080</td>
      <td>0.286</td>
      <td>2.558</td>
      <td>3.625</td>
      <td>0.006</td>
      <td>0.004</td>
      <td>2130.0</td>
      <td>2528.0</td>
      <td>1.00</td>
    </tr>
    <tr>
      <th>t_1</th>
      <td>0.929</td>
      <td>0.118</td>
      <td>0.712</td>
      <td>1.151</td>
      <td>0.002</td>
      <td>0.002</td>
      <td>3090.0</td>
      <td>2802.0</td>
      <td>1.00</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<div class="cell" data-execution_count="33">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>tasa_mean <span class="op">=</span> idata_cat.posterior[<span class="st">'tasa'</span>].mean((<span class="st">"chain"</span>, <span class="st">"draw"</span>))</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>tasa_hdi <span class="op">=</span> az.hdi(idata_cat.posterior[<span class="st">"tasa"</span>].values)</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>pc_hdi <span class="op">=</span> az.hdi(idata_cat.posterior[<span class="st">'pc'</span>])[<span class="st">"pc"</span>]</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>_, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">5</span>), sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>ax.plot(años, accidentes, <span class="st">'.'</span>)</span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">"Número de accidentes"</span>)</span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">"Año"</span>)<span class="op">;</span></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a>ax.vlines(idata_cat.posterior[<span class="st">'pc'</span>].mean((<span class="st">"chain"</span>, <span class="st">"draw"</span>)),</span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a>          accidentes.<span class="bu">min</span>(),</span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a>          accidentes.<span class="bu">max</span>(),</span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a>          color<span class="op">=</span><span class="st">'C1'</span>, lw<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true" tabindex="-1"></a>ax.fill_betweenx([accidentes.<span class="bu">min</span>(), accidentes.<span class="bu">max</span>()], pc_hdi[<span class="dv">0</span>], pc_hdi[<span class="dv">1</span>], alpha<span class="op">=</span><span class="fl">0.3</span>, color<span class="op">=</span><span class="st">'C1'</span>)</span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true" tabindex="-1"></a>ax.plot(años, tasa_mean,  <span class="st">'k'</span>, lw<span class="op">=</span><span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb45-19"><a href="#cb45-19" aria-hidden="true" tabindex="-1"></a>ax.fill_between(años, tasa_hdi[:,<span class="dv">0</span>], tasa_hdi[:,<span class="dv">1</span>], alpha<span class="op">=</span><span class="fl">0.3</span>, color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb45-20"><a href="#cb45-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-21"><a href="#cb45-21" aria-hidden="true" tabindex="-1"></a>faltante0 <span class="op">=</span> idata_cat.posterior[<span class="st">"acc_missing"</span>].sel(acc_missing_dim_0<span class="op">=</span><span class="dv">0</span>).mean((<span class="st">"chain"</span>, <span class="st">"draw"</span>))</span>
<span id="cb45-22"><a href="#cb45-22" aria-hidden="true" tabindex="-1"></a>faltante1 <span class="op">=</span> idata_cat.posterior[<span class="st">"acc_missing"</span>].sel(acc_missing_dim_0<span class="op">=</span><span class="dv">1</span>).mean((<span class="st">"chain"</span>, <span class="st">"draw"</span>))</span>
<span id="cb45-23"><a href="#cb45-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-24"><a href="#cb45-24" aria-hidden="true" tabindex="-1"></a>ax.plot(años[np.isnan(accidentes)], [faltante0, faltante1], <span class="st">"C2s"</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="02_Programación_probabilística_files/figure-html/cell-34-output-1.png" class="img-fluid"></p>
</div>
</div>
</section>
</section>
<section id="pruebas-predictivas-a-posteriori" class="level2">
<h2 class="anchored" data-anchor-id="pruebas-predictivas-a-posteriori">Pruebas predictivas a posteriori</h2>
<p>La prueba consiste en comparar los datos observados con los datos predichos a partir del <em>a posteriori</em>.</p>
<p>Las pruebas predictivas <em>a posteriori</em> son pruebas de auto-consistencia. Este ejercicio nos permite evaluar si el modelo es razonable, la idea general no es determinar si un modelo es <em>correcto</em> o no ya que como dijo George Box <em>“todos los modelos están equivocados, pero algunos son útiles”</em>. El grado de confianza en la <em>verosimilitud</em> de los modelos ciertamente es distinta entre practicantes de distintas disciplinas científicas, en disciplinas como física cuando se estudian sistemas relativamente simples bajo condiciones experimentales extremadamente controladas y haciendo uso de <em>teorías fuertes</em>, es probable que se le asigne un alto grado de confianza a ciertos modelos. Pero esto no suele ser cierto en disciplinas como ciencias sociales o biología (aunque sospecho que la variabilidad encontrada en biología ¡es muy alta!). En el caso de contar con <em>a prioris</em> muy informativos la evaluación de un modelo también puede ser usado para evaluar si los propios datos son razonables, indicando que tal vez sea necesario conseguir nuevos datos o revisar como se obtuvieron los datos o como se procesaron.</p>
<p>En definitiva la principal utilidad de las pruebas predictivas <em>a posteriori</em> debería ser el permitirnos dar una segunda mirada, crítica, al modelo y tratar de entender la razón de discrepancias sistemáticas (si las hubiera), estas discrepancias nos pueden llevar a entender mejor los límites del modelo, abandonar el modelo por completo o tal vez mejorarlo.</p>
<p>Si bien se han desarrollado métodos <em>formales</em> o <em>cuantitativos</em> para realizar pruebas predictivas <em>a posteriori</em>, una aproximación que suele ser más informativa y simple de interpretar es realizar gráficas, como veremos a continuación.</p>
<p>Usando PyMC podemos calcular la distribución predictiva a posteriori de la siguiente forma</p>
<div class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>idata_cat.extend(pm.sample_posterior_predictive(idata_cat, model<span class="op">=</span>modelo_cat, random_seed<span class="op">=</span><span class="dv">1791</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Sampling: [acc_observed]</code></pre>
</div>
<div class="cell-output cell-output-display">

<style>
    /* Turns off some styling */
    progress {
        /* gets rid of default border in Firefox and Opera. */
        border: none;
        /* Needs to be in here for Safari polyfill so background images work as expected. */
        background-size: auto;
    }
    progress:not([value]), progress:not([value])::-webkit-progress-bar {
        background: repeating-linear-gradient(45deg, #7e7e7e, #7e7e7e 10px, #5c5c5c 10px, #5c5c5c 20px);
    }
    .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
        background: #F44336;
    }
</style>
</div>
<div class="cell-output cell-output-display">

    <div>
      <progress value="4000" class="" max="4000" style="width:300px; height:20px; vertical-align: middle;"></progress>
      100.00% [4000/4000 00:00&lt;00:00]
    </div>
    
</div>
</div>
<p>Si bien es posible construir nuestras propias pruebas predictivas a posteriori, a continuación usaremos dos funciones de ArviZ.</p>
<div class="cell" data-execution_count="35">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>_, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">4</span>))</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>az.plot_ppc(idata_cat, ax<span class="op">=</span>ax[<span class="dv">0</span>])</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="st">"acc"</span>)</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>az.plot_loo_pit(idata_cat, <span class="st">"acc_observed"</span>, ax<span class="op">=</span>ax[<span class="dv">1</span>], use_hdi<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_yticks([])<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="02_Programación_probabilística_files/figure-html/cell-36-output-1.png" class="img-fluid"></p>
</div>
</div>
<ul>
<li><p><code>az.plot_ppc</code>: Por defecto esta función representa los datos observados, varias muestras de la distribución predictiva a posteriori (predicciones) y la distribución media de estas muestras. Si los datos son discretos se usan histogramas, si los datos son continuos KDEs.</p></li>
<li><p><code>az.plot_loo_pit</code>: Muestra la diferencia entre datos observados y predichos (linea azul), de tal forma que si no hubiera diferencia obtendríamos una distribuión uniforme (linea blanca). En el eje x están los cuantiles de la distribución. Por lo que si hubiera diferencia alrededor de 0.5 esto implica diferencia alrededor de la mediana, si en cambio la diferencia estuviera entre 0 y 0.2 esto implicaría diferencias en la cola izquierda (primer 20% de la masa total de la distribución), etc. Si la curva está por encima de la linea blanca esto quiere decir que hay más observaciones que predicciones en esa región, y si la curva está por debajo lo contrario. El grafico muestra un banda, que indica las desviaciones esperadas respecto de la distribución uniforme para el tamaño de muestra dado. Cualquier diferencia dentro de esa banda es “esperable”.</p></li>
</ul>
</section>
<section id="pruebas-predictivas-a-priori" class="level2">
<h2 class="anchored" data-anchor-id="pruebas-predictivas-a-priori">Pruebas predictivas <em>a priori</em></h2>
<p>Las pruebas predictivas <em>a prior</em> son una forma de evaluar el modelo. Una vez definido un modelo Bayesiano se generan muestras a partir del mismo, pero <em>sin condicionar</em> en los datos <span class="math inline">\(\tilde{y}\)</span>, es decir se calcula la distribución posible de datos (sintéticos) sin haber visto los datos reales.</p>
<p><span class="math display">\[
p(y^\ast) =  \int_{\Theta} p(y^\ast \mid \theta) \; p(\theta) \; d\theta
\]</span></p>
<p>Los datos generados son predictivos ya que son los datos que el modelo esperara ver, es decir son datos no observados pero potencialmente observables. La prueba consiste en comparar los datos observados con el conocimiento previo que tenemos sobre el problema, ojo que NO se trata de comparar con los datos observados!</p>
<p>Las pruebas predictivas <em>a priori</em> son pruebas de consistencia con nuestro conocimiento previo. Este ejercicio nos permite evaluar si el modelo es razonable, en el sentido de si es capaz de generar datos que concuerdan con lo que sabemos de un problema. Por ejemplo un modelo del tamaño de planetas no es muy razonable si predice planetas de escala nanométrica o incluso de unos pocos kilómetros. Es importante destacar que dado suficiente cantidad y calidad de datos un modelo de este tipo podría dar resultados razonables, una vez condicionado a esos datos. Es decir el posterior podría no incluir, o asignar probabilidades despreciables a nanoplanetas.</p>
<p>En definitiva la principal utilidad de las pruebas predictivas <em>a prior</em> es la de permitirnos inspecticionar críticamente un modelo y tratar de entender el comportamiento del modelo las discrepancias con el conocimiento previo nos pueden llevarnos a entender mejor los límites del modelo, abandonar el modelo por completo o tal vez mejorarlo por ejemplo usando priors más angostos u otros likelihoods.</p>
<p>Usando PyMC podemos calcular la distribución predictiva a priori de la siguiente forma</p>
<div class="cell" data-execution_count="36">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>idata_cat.extend(pm.sample_prior_predictive(model<span class="op">=</span>modelo_cat, random_seed<span class="op">=</span><span class="dv">1791</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Sampling: [acc_missing, acc_observed, pc, t_0, t_1]</code></pre>
</div>
</div>
<div class="cell" data-execution_count="37">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>_, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>,<span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>), sharey<span class="op">=</span><span class="st">"row"</span>, sharex<span class="op">=</span><span class="st">"col"</span>)</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>,<span class="dv">0</span>].plot(años[np.isfinite(accidentes)],</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>        idata_cat.prior_predictive[<span class="st">"acc_observed"</span>].sel(draw<span class="op">=</span><span class="dv">50</span>).squeeze(<span class="st">"chain"</span>).T, <span class="st">"."</span>)<span class="op">;</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>a_sample <span class="op">=</span> idata_cat.prior.sel(draw<span class="op">=</span><span class="dv">50</span>)</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>coco <span class="op">=</span> np.full_like(años,  a_sample[<span class="st">"t_1"</span>].item(), dtype<span class="op">=</span><span class="bu">float</span>)</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>coco[a_sample[<span class="st">"pc"</span>]<span class="op">&gt;=</span>años] <span class="op">=</span> a_sample[<span class="st">"t_0"</span>].item()</span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>,<span class="dv">0</span>].step(años, coco)</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>,<span class="dv">0</span>].set_ylabel(<span class="st">"número de accidentes"</span>)</span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>az.plot_dist(idata_cat.prior_predictive[<span class="st">"acc_observed"</span>].sel(draw<span class="op">=</span><span class="dv">50</span>), ax<span class="op">=</span>ax[<span class="dv">0</span>,<span class="dv">1</span>], rotated<span class="op">=</span><span class="va">True</span>)<span class="op">;</span></span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>,<span class="dv">0</span>].plot(años[np.isfinite(accidentes)],</span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a>        idata_cat.prior_predictive[<span class="st">"acc_observed"</span>].squeeze(<span class="st">"chain"</span>).T, <span class="st">"C0."</span>, alpha<span class="op">=</span><span class="fl">0.05</span>)<span class="op">;</span></span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>,<span class="dv">0</span>].set_ylabel(<span class="st">"número de accidentes"</span>)</span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>,<span class="dv">0</span>].set_xlabel(<span class="st">"años"</span>)</span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-19"><a href="#cb51-19" aria-hidden="true" tabindex="-1"></a>az.plot_dist(idata_cat.prior_predictive[<span class="st">"acc_observed"</span>], ax<span class="op">=</span>ax[<span class="dv">1</span>,<span class="dv">1</span>], rotated<span class="op">=</span><span class="va">True</span>)<span class="op">;</span></span>
<span id="cb51-20"><a href="#cb51-20" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>,<span class="dv">1</span>].set_xlabel(<span class="st">"probabilidad"</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="02_Programación_probabilística_files/figure-html/cell-38-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>La primer fila de la figura anterior muestra una muestra de la distribución predictiva a priori. A la izquierda el número de accidentes por año (puntos azules). Y la tasa media en turquesa mostrando un valor de <span class="math inline">\(\approx 0.3\)</span> antes de 1880 y 1.3 con posterioridad a esa fecha. A la derecha un histograma de la cantidad de accidentes.</p>
<p>La segunda fila muestra lo mismo pero agregado para las 500 muestras que le pedimos a PyMC. Se ve una distribución de accidentes uniforme a lo largo de los años, esto es esperable dado que hemos definido el mismo prior para ambas tasas. Además, podemos ver que nuestro modelo favorece valores relativamente bajos de accidentes por año con el 85% de la masa para valores iguales o menores a 3.</p>
</section>
<section id="comparando-grupos" class="level2">
<h2 class="anchored" data-anchor-id="comparando-grupos">Comparando grupos</h2>
<p>Una tarea común al analizar datos es comparar grupos. Podríamos estar interesados en analizar los resultados de un ensayo clínico donde se busca medir la efectividad de una droga, o la reducción de la cantidad de accidentes de tránsito al introducir un cambio en las regulaciones de tránsito, o el desempeño de estudiantes bajo diferentes aproximaciones pedagógicas, etc. Este tipo de preguntas se suele resolver en el marco de lo que se conoce como pruebas de hipótesis que busca declarar si una observación es estadísticamente significativa o no. Nosotros tomaremos una ruta alternativa.</p>
<p>Al comparar grupos debemos decidir que característica(s) vamos a usar. Una característica común es la media de cada grupo. En ese caso podemos calcular la distribución <em>a posteriori</em> de la diferencia entre medias. Para ayudarnos a entender este posterior usaremos 3 herramientas:</p>
<ul>
<li>Un <em>posteriorplot</em> con un valor de referencia</li>
<li>Una medida llamada <em>d de Cohen</em></li>
<li>La probabilidad de superioridad</li>
</ul>
<p>En el capítulo anterior ya vimos un ejemplo de cómo usar <em>posteriorplot</em> con un valor de referencia, pronto veremos otro ejemplo. Las novedades aquí son el d de Cohen y la probabilidad de superioridad, dos maneras populares de expresar el tamaño del efecto.</p>
<section id="d-de-cohen" class="level3">
<h3 class="anchored" data-anchor-id="d-de-cohen">d de Cohen</h3>
<p>Una medida muy común, al menos en ciertas disciplinas, para cuantificar el tamaño del efecto es el d de Cohen</p>
<p><span class="math display">\[
\frac{\mu_2 - \mu_1}{\sqrt{\frac{\sigma_2^2 + \sigma_1^2}{2}}}
\]</span></p>
<p>De acuerdo con esta expresión, el tamaño del efecto es la diferencia de las medias con respecto a la desviación estándar combinada de ambos grupos. Ya que es posible obtener una distribución <em>a posteriori</em> de medias y de desviaciones estándar, también es posible calcular una distribución <em>a posteriori</em> de los valores d de Cohen. Por supuesto, si sólo necesitamos o queremos una estimación puntual, podríamos calcular la media de esa distribución <em>a posteriori</em>. En general, al calcular una desviación estándar combinada, se toma en cuenta el tamaño de la muestra de cada grupo explícitamente, pero la ecuación de <em>d de Cohen</em> omite el tamaño de la muestra, la razón es que tomamos estos valores del <em>posterior</em> (por lo que ya estamos considerando la incertidumbre de las desviaciones estándar).</p>
<blockquote class="blockquote">
<p>Un d de Cohen es una forma de medir el tamaño del efecto donde la diferencia de las medias se estandariza al considerar las desviaciones estándar de ambos grupos.</p>
</blockquote>
<p>Cohen introduce la variabilidad de cada grupo al usar sus desviaciones estándar. Esto es realmente importante, una diferencia de 1 cuando la desviación estándar es de 0.1 es muy grande en comparación con la misma diferencia cuando la desviación estándar es 10. Además, un cambio de x unidades de un grupo respecto del otro podría explicarse por cada punto <em>desplazandose</em> exactamente x unidades o la mitad de los puntos sin cambiar mientras la otra mitad cambia 2x unidades, y así con otras combinaciones. Por lo tanto, incluir las variaciones intrínsecas de los grupos es una forma de poner las diferencias en contexto. Re-escalar (estandarizar) las diferencias nos ayuda a dar sentido a la diferencia entre grupos y facilita evaluar si el cambio es importante, incluso cuando no estamos muy familiarizados con la escala utilizada para las mediciones.</p>
<p>Un d de Cohen se puede interpretar como un Z-score. Un Z-score es la cantidad de desviaciones estándar que un valor difiere del valor medio de lo que se está observando o midiendo, puede ser positivo o negativo dependiendo de si la diferencia es por exceso o por defecto. Por lo tanto, un d de Cohen de -1.2, indica que la media de un grupo está 1.2 desviación estándar por debajo de la media del otro grupo.</p>
<p>Incluso con las diferencias de medias estandarizadas, puede ser necesario tener que <em>calibrarnos</em> en función del contexto de un problema determinado para poder decir si un valor de d de Cohen es <em>grande</em>, <em>pequeño</em>, <em>mediano</em>, <em>importante</em>, <em>despreciable</em>, etc. Afortunadamente, esta calibración se puede adquirir con la práctica, a modo de ejemplo si estamos acostumbrados a realizar varios análisis para más o menos el mismo tipo de problemas, podemos acostumbrarnos a un d de Cohen de entre 0.8 y 1.2, de modo que si obtenemos un valor de 2 podría ser que estamos frente a algo importante, inusual (¡o un error!). Una alternativa es consultar con expertos en el tema.</p>
<p>Una muy buena página web para explorar cómo se ven los diferentes valores de Cohen’s es http://rpsychologist.com/d3/cohend. En esa página, también encontrarán otras formas de expresar el tamaño del efecto; algunas de ellos podrían ser más intuitivas, como la probabilidad de superioridad que analizaremos a continuación.</p>
</section>
<section id="probabilidad-de-superioridad" class="level3">
<h3 class="anchored" data-anchor-id="probabilidad-de-superioridad">Probabilidad de superioridad</h3>
<p>Esta es otra forma de informar el tamaño del efecto y se define como la probabilidad que un dato tomado al azar de un grupo tenga un valor mayor que un punto tomado al azar del otro grupo. Si suponemos que los datos que estamos utilizando se distribuyen de forma Gaussiana, podemos calcular la probabilidad de superioridad a partir de la d de Cohen usando la expresión:</p>
<p><span class="math display">\[\begin{equation} \label{eq_ps}
ps = \Phi \left ( \frac{\delta}{\sqrt{2}} \right)
\end{equation}\]</span></p>
<p>Donde <span class="math inline">\(\Phi\)</span> es la distribución normal acumulada y <span class="math inline">\(\delta\)</span> es el d de Cohen. Podemos calcular una estimación puntual de la probabilidad de superioridad (lo que generalmente se informa) o podemos calcular la distribución <em>a posteriori</em>. Si no estamos de acuerdo con la suposición de normalidad, podemos descartar esta fórmula y calcularla directamente a partir del <em>posterior</em> sin necesidad de asumir ninguna distribución. Esta es una de las ventajas de usar métodos de muestreo para estimar el <em>a posteriori</em>, una vez obtenidas las muestras lo que podemos hacer con ellas es muy flexible.</p>
<section id="el-conjunto-de-datos-tips" class="level4">
<h4 class="anchored" data-anchor-id="el-conjunto-de-datos-tips">El conjunto de datos <em>tips</em></h4>
<p>Para explorar el tema de esta sección, vamos a usar el conjunto de datos tips (propinas). Estos datos fueron informados por primera vez por Bryant, P. G. and Smith, M (1995) <em>Practical Data Analysis: Case Studies in Business Statistics</em>.</p>
<p>Queremos estudiar el efecto del día de la semana sobre la cantidad de propinas en un restaurante. Para este ejemplo, los diferentes grupos son los días. Comencemos el análisis cargando el conjunto de datos como un DataFrame de Pandas usando solo una línea de código. Si no está familiarizado con Pandas, el comando <em>tail</em> se usa para mostrar las últimas filas de un DataFrame:</p>
<div class="cell" data-scrolled="true" data-execution_count="38">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>tips <span class="op">=</span> pd.read_csv(<span class="st">'datos/propinas.csv'</span>)</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>tips.tail()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="38">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>total_bill</th>
      <th>tip</th>
      <th>sex</th>
      <th>smoker</th>
      <th>day</th>
      <th>time</th>
      <th>size</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>239</th>
      <td>29.03</td>
      <td>5.92</td>
      <td>Male</td>
      <td>No</td>
      <td>Sat</td>
      <td>Dinner</td>
      <td>3</td>
    </tr>
    <tr>
      <th>240</th>
      <td>27.18</td>
      <td>2.00</td>
      <td>Female</td>
      <td>Yes</td>
      <td>Sat</td>
      <td>Dinner</td>
      <td>2</td>
    </tr>
    <tr>
      <th>241</th>
      <td>22.67</td>
      <td>2.00</td>
      <td>Male</td>
      <td>Yes</td>
      <td>Sat</td>
      <td>Dinner</td>
      <td>2</td>
    </tr>
    <tr>
      <th>242</th>
      <td>17.82</td>
      <td>1.75</td>
      <td>Male</td>
      <td>No</td>
      <td>Sat</td>
      <td>Dinner</td>
      <td>2</td>
    </tr>
    <tr>
      <th>243</th>
      <td>18.78</td>
      <td>3.00</td>
      <td>Female</td>
      <td>No</td>
      <td>Thur</td>
      <td>Dinner</td>
      <td>2</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>Para este ejemplo solo vamos a usar las columnas <code>day</code> y <code>tip</code> y vamos a usar la función <code>plot_forest</code> de ArviZ. Aún cuando ArviZ está pensado para análisis de modelos Bayesianos algunos de sus funciones pueden ser útiles para analizar datos.</p>
<div class="cell" data-execution_count="39">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>az.plot_forest(tips.pivot(columns<span class="op">=</span><span class="st">'day'</span>, values<span class="op">=</span><span class="st">'tip'</span>).to_dict(<span class="st">'list'</span>),</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>               kind<span class="op">=</span><span class="st">'ridgeplot'</span>,</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>               hdi_prob<span class="op">=</span><span class="dv">1</span>,</span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>               figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">4</span>))<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="02_Programación_probabilística_files/figure-html/cell-40-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>A fin de simplificar el análisis vamos a crear 2 variables: * La variable <code>categories</code> contiene los nombres de los días (abreviados y en inglés) * La variable <code>idx</code> codifica los días de la semana como enteros entre 0 y 3.</p>
<div class="cell" data-execution_count="40">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>categories <span class="op">=</span> np.array([<span class="st">'Thur'</span>, <span class="st">'Fri'</span>, <span class="st">'Sat'</span>, <span class="st">'Sun'</span>])</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>tip <span class="op">=</span> tips[<span class="st">'tip'</span>].values</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>idx <span class="op">=</span> pd.Categorical(tips[<span class="st">'day'</span>], categories<span class="op">=</span>categories).codes</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El modelo para este problema es basicamente igual a <code>model_g</code>, con la diferencia que <span class="math inline">\(\mu\)</span> y <span class="math inline">\(\sigma\)</span> ahora serán vectores en vez de escalares. La sintáxis de PyMC es super-útil para estos caso, en vez de usar <code>for loops</code> escribimos el modelo de forma vectorizada, para ello especificamos el argumento <code>shape</code> para los priors <span class="math inline">\(\mu\)</span> y <span class="math inline">\(\sigma\)</span> y para el likelihood usamos la variable <code>idx</code> para indexar de forma adecuada <span class="math inline">\(\mu\)</span> y <span class="math inline">\(\sigma\)</span> para asegurar que usamos los parámetros correctos para cada grupo. En este ejemplo un <span class="math inline">\(\mu\)</span> para jueves, otra para viernes, otra para sábado y una cuarta para domingo, y lo mismo para <span class="math inline">\(\sigma\)</span>.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> pm.Model() <span class="im">as</span> comparing_groups:</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>        μ <span class="op">=</span> pm.Normal(<span class="st">'μ'</span>, mu<span class="op">=</span><span class="dv">0</span>, sigma<span class="op">=</span><span class="dv">10</span>, shape<span class="op">=</span><span class="dv">4</span>)</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>        σ <span class="op">=</span> pm.HalfNormal(<span class="st">'σ'</span>, sigma<span class="op">=</span><span class="dv">10</span>, shape<span class="op">=</span><span class="dv">4</span>)</span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> pm.Normal(<span class="st">'y'</span>, mu<span class="op">=</span>μ[idx], sigma<span class="op">=</span>σ[idx], observed<span class="op">=</span>tip)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>PyMC provee una sintaxis alternativa, la cual consisten en especificar coordenadas y dimensiones. La ventaja de esta alternativa es que permite una mejor integración con ArviZ.</p>
<p>Veamos, en este ejemplo tenemos 4 valores para las medias y 4 para las desviaciones estandard, y por eso usamos <code>shape=4</code>. El InferenceData tendrá 4 indices <code>0, 1, 2, 3</code> correspondientes a cada uno de los 4 días. Pero es trabajo del usuario asociaer esos indices númericos con los días.</p>
<p>Al usar coordendas y dimensiones nosotros podremos usar los rótulos <code>'Thur', 'Fri', 'Sat', 'Sun'</code> para referirnos a los parámetros relacionados con cada uno de estos días. ArviZ también podrá hacer uso de estos rótulos. Vamos a especificar dos coordenadas <code>days</code> con las dimensiones <code>'Thur', 'Fri', 'Sat', 'Sun'</code> y “days_flat” que contendrá los mismo rótulos pero repetidos según el órden y longitud que corresponda con cada observación. Esto último será útil para poder obtener pruebas predictivas a posteriori para cada día.</p>
<div class="cell" data-execution_count="41">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>coords <span class="op">=</span> {<span class="st">"days"</span>: categories, <span class="st">"days_flat"</span>:categories[idx]}</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> pm.Model(coords<span class="op">=</span>coords) <span class="im">as</span> comparing_groups:</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>    μ <span class="op">=</span> pm.HalfNormal(<span class="st">'μ'</span>, sigma<span class="op">=</span><span class="dv">5</span>, dims<span class="op">=</span><span class="st">"days"</span>)</span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>    σ <span class="op">=</span> pm.HalfNormal(<span class="st">'σ'</span>, sigma<span class="op">=</span><span class="dv">1</span>, dims<span class="op">=</span><span class="st">"days"</span>)</span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> pm.Gamma(<span class="st">'y'</span>, mu<span class="op">=</span>μ[idx], sigma<span class="op">=</span>σ[idx], observed<span class="op">=</span>tip, dims<span class="op">=</span><span class="st">"days_flat"</span>)</span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a>    idata_cg <span class="op">=</span> pm.sample()</span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a>    idata_cg.extend(pm.sample_posterior_predictive(idata_cg))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (4 chains in 4 jobs)
NUTS: [μ, σ]</code></pre>
</div>
<div class="cell-output cell-output-display">

<style>
    /* Turns off some styling */
    progress {
        /* gets rid of default border in Firefox and Opera. */
        border: none;
        /* Needs to be in here for Safari polyfill so background images work as expected. */
        background-size: auto;
    }
    progress:not([value]), progress:not([value])::-webkit-progress-bar {
        background: repeating-linear-gradient(45deg, #7e7e7e, #7e7e7e 10px, #5c5c5c 10px, #5c5c5c 20px);
    }
    .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
        background: #F44336;
    }
</style>
</div>
<div class="cell-output cell-output-display">

    <div>
      <progress value="8000" class="" max="8000" style="width:300px; height:20px; vertical-align: middle;"></progress>
      100.00% [8000/8000 00:02&lt;00:00 Sampling 4 chains, 0 divergences]
    </div>
    
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Sampling 4 chains for 1_000 tune and 1_000 draw iterations (4_000 + 4_000 draws total) took 3 seconds.
Sampling: [y]</code></pre>
</div>
<div class="cell-output cell-output-display">

<style>
    /* Turns off some styling */
    progress {
        /* gets rid of default border in Firefox and Opera. */
        border: none;
        /* Needs to be in here for Safari polyfill so background images work as expected. */
        background-size: auto;
    }
    progress:not([value]), progress:not([value])::-webkit-progress-bar {
        background: repeating-linear-gradient(45deg, #7e7e7e, #7e7e7e 10px, #5c5c5c 10px, #5c5c5c 20px);
    }
    .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
        background: #F44336;
    }
</style>
</div>
<div class="cell-output cell-output-display">

    <div>
      <progress value="4000" class="" max="4000" style="width:300px; height:20px; vertical-align: middle;"></progress>
      100.00% [4000/4000 00:00&lt;00:00]
    </div>
    
</div>
</div>
<p>Una vez obtenido un <em>a posteriori</em> podemos hacer todos los análisis que creamos pertinentes con el. Primero hagamos una prueba predictiva a posteriori. Vemos que en general somos capaces de capturar la forma general de las distribuciones, pero hay detalles que se nos escapan. Esto puede deberse al tamaño relativamente pequeño de la muestra, a que hay otros factores además del día que tienen influencia en las propinas o una combinación de ambas. Por ahora seguiremos con el análisis considerando que el modelo es lo suficientemente bueno</p>
<div class="cell" data-execution_count="42">
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>_, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">2</span>)</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>az.plot_ppc(idata_cg, num_pp_samples<span class="op">=</span><span class="dv">100</span>, coords<span class="op">=</span>{<span class="st">"days_flat"</span>:[categories]}, flatten<span class="op">=</span>[], ax<span class="op">=</span>axes)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="02_Programación_probabilística_files/figure-html/cell-43-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Podemos ver la distribución de cada uno de los parámetros haciendo</p>
<div class="cell" data-execution_count="43">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>az.plot_posterior(idata_cg, var_names<span class="op">=</span><span class="st">"μ"</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">3</span>))<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="02_Programación_probabilística_files/figure-html/cell-44-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>La figura anterior es bastante informativa, por ejemplo vemos que los valores medios de las propinas son de unos pocos centavos y que para los domingos el valor es ligeramente más alto que para el resto de los días analizados.</p>
<p>Pero quizá consideramos que puede ser mejor mostrar los datos de otra forma. Por ejemplo podemos calcular todas las diferencias de medias <em>a posteriori</em> entre si. Además podríamos quere usar alguna medida del tamaño del efecto que sea popular entre nuestra audiencia, como podrían ser la <em>probabilidad de superioridad</em> o <em>d de Cohen</em>.</p>
<p><strong>Cohen’s d</strong></p>
<p><span class="math display">\[
\frac{\mu_2 - \mu_1}{\sqrt{\frac{\sigma_1^2 + \sigma_2^2}{2}}}
\]</span></p>
<ul>
<li>Se puede interpretar como un <em>z-score</em>. Cuántas desviaciones estándar una media de un grupo está por encima (o por debajo) de la media del otro grupo</li>
<li><a href="http://rpsychologist.com/d3/cohend">Ejemplo interactivo</a></li>
</ul>
<p><strong>Probabilidad de superioridad</strong></p>
<ul>
<li>La probabilidad que un dato tomado de un grupo sea mayor que la de un dato tomado del otro grupo.</li>
<li>Si suponemos que los datos se distribuyen normalmente, entonces:</li>
</ul>
<p><span class="math display">\[\begin{equation} \label{eq_ps}
ps = \Phi \left ( \frac{\delta}{\sqrt{2}} \right)
\end{equation}\]</span></p>
<p><span class="math inline">\(\Phi\)</span> es la <code>cdf</code> de una distribución normal <span class="math inline">\(\delta\)</span> es el valor del Cohen’s d.</p>
<p>Con el siguiente código usamos <code>plot_posterior</code> para graficar todas las diferencias no triviales o redundantes. Es decir evitamos las diferencias de un día con sigo mismo y evitamos calcular ‘Fri - Thur’ si ya hemos calculado ‘Thur- Fri’. Si lo vieramos como una matriz de diferencias solo estaríamos calculando la porción triangular superior.</p>
<div class="cell" data-execution_count="44">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>cg_posterior <span class="op">=</span> az.extract(idata_cg)</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>dist <span class="op">=</span> stats.norm()</span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>comparisons <span class="op">=</span> [(categories[i], categories[j]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>) <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i<span class="op">+</span><span class="dv">1</span>, <span class="dv">4</span>)]</span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>_, axes <span class="op">=</span> plt.subplots(<span class="dv">3</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">13</span>, <span class="dv">9</span>), sharex<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i, j), ax <span class="kw">in</span> <span class="bu">zip</span>(comparisons, axes.ravel()):</span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a>    means_diff <span class="op">=</span> cg_posterior[<span class="st">'μ'</span>].sel(days<span class="op">=</span>i) <span class="op">-</span> cg_posterior[<span class="st">'μ'</span>].sel(days<span class="op">=</span>j)</span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a>    d_cohen <span class="op">=</span> (means_diff <span class="op">/</span></span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a>               np.sqrt((cg_posterior[<span class="st">'σ'</span>].sel(days<span class="op">=</span>i)<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> </span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true" tabindex="-1"></a>                        cg_posterior[<span class="st">'σ'</span>].sel(days<span class="op">=</span>j)<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> <span class="dv">2</span>)</span>
<span id="cb61-15"><a href="#cb61-15" aria-hidden="true" tabindex="-1"></a>              ).mean().item()</span>
<span id="cb61-16"><a href="#cb61-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb61-17"><a href="#cb61-17" aria-hidden="true" tabindex="-1"></a>    ps <span class="op">=</span> dist.cdf(d_cohen<span class="op">/</span>(<span class="dv">2</span><span class="op">**</span><span class="fl">0.5</span>))</span>
<span id="cb61-18"><a href="#cb61-18" aria-hidden="true" tabindex="-1"></a>    az.plot_posterior(means_diff.values, ref_val<span class="op">=</span><span class="dv">0</span>, ax<span class="op">=</span>ax)</span>
<span id="cb61-19"><a href="#cb61-19" aria-hidden="true" tabindex="-1"></a>    ax.set_title(<span class="ss">f"</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss"> - </span><span class="sc">{</span>j<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb61-20"><a href="#cb61-20" aria-hidden="true" tabindex="-1"></a>    ax.plot(<span class="dv">0</span>, label<span class="op">=</span><span class="ss">f"Cohen's d = </span><span class="sc">{</span>d_cohen<span class="sc">:.2f}</span><span class="ch">\n</span><span class="ss">Prob sup = </span><span class="sc">{</span>ps<span class="sc">:.2f}</span><span class="ss">"</span>, alpha<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb61-21"><a href="#cb61-21" aria-hidden="true" tabindex="-1"></a>    ax.legend(loc<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="02_Programación_probabilística_files/figure-html/cell-45-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Una forma de interpretar estos resultados es comparando el valor de referencia con el intervalo HDI. De acuerdo con la figura anterior, tenemos solo un caso cuando el 94% HDI excluye el valor de referencia de cero, la diferencia en las propinas entre el jueves y el domingo. Para todos los demás ejemplos, no podemos descartar una diferencia de cero (de acuerdo con los criterios de superposición de valores de referencia de HDI). Pero incluso para ese caso, ¿es una diferencia promedio de ≈0.5 dólares lo suficientemente grande? ¿Es suficiente esa diferencia para aceptar trabajar el domingo y perder la oportunidad de pasar tiempo con familiares o amigos? ¿Es suficiente esa diferencia para justificar promediar las propinas durante los cuatro días y dar a cada mozo/a la misma cantidad de dinero de propina? Este tipo de preguntas es crucial para interpretar los datos y/o tomar decisiones, pero las respuestas no las puede ofrecer la estadística de forma automática (ni ningún otro procedimiento). La estadística solo pueden ayudar en la interpretación y/o toma de decisiones.</p>
<p>Nota: Dependiendo del público el gráfico anterior puede que esté demasiado “cargado”, quizá es útil para una discusión dentro del equipo de trabajo, pero para un público en general quizá convenga sacar elementos o repartir la información entre una figura y una tabla o dos figuras.</p>
</section>
</section>
</section>
<section id="resumen" class="level2">
<h2 class="anchored" data-anchor-id="resumen">Resumen</h2>
<p>Aunque la estadística Bayesiana es conceptualmente simple, los modelos probabilísticos a menudo conducen a expresiones analíticamente intratables. Durante muchos años, esta fue una gran barrera que obstaculizó la adopción amplia de métodos Bayesianos. Afortunadamente, la matemática, la física y la informática vinieron al rescate en forma de métodos numéricos capaces, al menos en principio, de resolver cualquier inferencia. La posibilidad de automatizar el proceso de inferencia ha llevado al desarrollo de los lenguajes de programación probabilista que permiten una clara separación entre la definición del modelo y la inferencia.</p>
<p>PyMC es una librería de Python para programación probabilística con una sintaxis simple, intuitiva y fácil de leer que también está muy cerca de la sintaxis estadística utilizada para describir modelos probabilísticos. En este capítulo introducimos PyMC revisando el problema de la moneda que vimos en el capítulo anterior. La diferencia es que no tuvimos que derivar analíticamente la distribución <em>a posteriori</em>. Los modelos en PyMC se definen dentro de un bloque <code>with</code>; para agregar una distribución de probabilidad a un modelo, solo necesitamos escribir una línea de código. Las distribuciones se pueden combinar y se pueden usar como priors (variables no observadas) o likelihoods (variables observadas). En la sintaxis de PyMC la única diferencia entre ambas es que para esta última debemos pasar los datos usando el argumento <code>observed</code>. Si todo va bien las muestras generadas por PyMC serán representativas de la distribución <em>a posteriori</em> y por lo tanto serán una representación de las consecuencias lógicas del modelo y los datos.</p>
<p>ArviZ es una librería que nos ayuda a explorar los modelos definidos por PyMC (u otroas librerías como PyStan, TFP, BeanMachine, etc). Una forma de usar el posterior para ayudarnos a tomar decisiones es comparando la ROPE con el intervalo HDI. También mencionamos brevemente la noción de funciones de pérdida, una aproximación formal para cuantificar los costos y beneficios asociados a la toma de decisiones. Aprendimos que las funciones de pérdida y las estimaciones puntuales están íntimamente asociadas.</p>
<p>Hasta este momento todos los ejemplos estuvieron basado en modelos con un solo parámetro. Sin embargo PyMC permite, en principiop, usar un número arbitrario de parámetros, esto lo ejemplificamos con un modelo Gaussiano y luego una generalización de este, el modelo t de Student. La distribución t de Student suele usarse como alternativa a la Gaussiana cuando queremos hacer inferencias robustas a valores aberrantes. Pronto veremos cómo se puede usar estos modelos como para construir regresiónes lineales.</p>
<p>Finalizamos comparanod medias entre grupos, una tarea común en análisis de datos. Si bien esto a veces se enmarca en el contexto de las pruebas de hipótesis, tomamos otra ruta y trabajamos este problema como una inferencia del tamaño del efecto.</p>
</section>
<section id="para-seguir-leyendo" class="level2">
<h2 class="anchored" data-anchor-id="para-seguir-leyendo">Para seguir leyendo</h2>
<ul>
<li><p>La <a href="https://www.pymc.io/welcome.html">documentación de PyMC</a> tiene varios ejemplos de como usar este librería y modelos de distinto tipo.</p></li>
<li><p><a href="https://github.com/quantopian/Probabilistic-Programming-and-Bayesian-Methods-for-Hackers">Probabilistic Programming and Bayesian Methods for Hackers</a> de Cameron Davidson-Pilon y varios otros contribuidores. Originalmente escrito en PyMC2 ha sido portado a PyMC</p></li>
<li><p><a href="http://twiecki.github.io/.">While My MCMC Gently Samples</a>. Un blog de Thomas Wiecki, desarrollador de PyMC.</p></li>
<li><p><a href="https://xcelab.net/rm/statistical-rethinking/">Statistical Rethinking by Richard McElreath</a> es probablemente el mejor libro introductorio de estadística Bayesiana. El libro usa R/Stan. Pero varias personas hemos contribuido para <a href="https://github.com/pymc-devs/resources/tree/main/Rethinking">portar el código a Python/PyMC</a></p></li>
<li><p><a href="https://sites.google.com/site/doingbayesiandataanalysis/home">Doing Bayesian Data Analysis</a> de John K. Kruschke es otro libro introductorio bastante accesible. La mayoría de los ejemplos de la primer edición están disponibles en <a href="https://github.com/aloctavodia/Doing_bayesian_data_analysis">Python/PyMC</a> y de la segunda edición <a href="https://github.com/JWarmenhoven/DBDA-python">acá</a>.</p></li>
</ul>
</section>
<section id="ejercicios" class="level2">
<h2 class="anchored" data-anchor-id="ejercicios">Ejercicios</h2>
<ol type="1">
<li><p>Usando PyMC reproducí los resultados del primer capítulo para el problema de la moneda (use los 3 priors usados en ese capítulo).</p></li>
<li><p>Reemplazá la distribución beta por una uniforme en el intervalo [0, 1] ¿Cómo cambia la velocidad del muestreo? ¿Y si se usas un intervalo más ámplio, como [-3, 3]?</p></li>
<li><p>Para el <code>modelo_g</code>. Usá una Gaussiana para la media, centrada en la media empírica. Probá modificar la desviación estándard de ese prior ¿Cuán robusto/sensible son los resultados a la elección del prior?</p></li>
<li><p>La Gaussiana es una distribución <em>sin límites</em> es decir es válida en el intervalo <span class="math inline">\([-\infty, \infty]\)</span>, en el ejemplo anterior la usamos para modelar datos que sabemos tienen límites ¿Qué opinas de esta elección?</p></li>
<li><p>Usando los datos de la velocidad de la luz, calculá la media y desviación estándar con y sin los <em>outilers</em>, compará esos valores con los obtenidos con el <code>modelo_g</code> y con el <code>modelo_t</code>.</p></li>
<li><p>Modificá el modelo de las propinas para usar una distribución t de Student, probá usando un solo <span class="math inline">\(\nu\)</span> para los cuatro grupos y también usando un valor de <span class="math inline">\(\nu\)</span> por grupo.</p></li>
<li><p>Calculá la probabilidad de superioridad a partir de las muestras del posterior (sin usar la formula de probabilidad de superioridad a partir de la d de Cohen). Comparar los resultados con los valores obtenidos a analíticamente.</p></li>
<li><p>Aplica al menos uno de los modelos visto en este capítulo a datos propios o de tu interés.</p></li>
</ol>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>